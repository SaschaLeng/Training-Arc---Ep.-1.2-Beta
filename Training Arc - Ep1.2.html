<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Training Arc: GtG Loop Tracker</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; object-src 'none';">
  <style>
  /* Reset and base */
  *, *::before, *::after { box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 650px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f8f8f8;
    color: #333;
    overflow-x: hidden;
  }
  input[type="checkbox"] {
    accent-color: #00BFFF;
    width: 18px;
    height: 18px;
    cursor: pointer;
  }

  /* Header and menu */
  .header-container {
    display: grid;
    grid-template-columns: 30px 1fr 30px; /* Left-spacer | Logo | Menu-container */
    align-items: center;
    width: 100%;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
    margin-bottom: 25px;
    height: 45px; /* Explicit height for better vertical centering of menu */
  }
  .header-container > div:first-child { /* Left spacer */
    grid-column: 1;
  }
  .logo-container {
    grid-column: 2;
    text-align: center;
    font-weight: 600;
    font-size: 1.5rem;
    color: #222;
  }
  .menu-container {
    grid-column: 3;
    justify-self: end;
    position: relative; /* For dropdown menu */
    display: flex;
    align-items: center;
    height: 100%; /* Ensure it fills grid cell height for menu centering */
  }
  .menu-icon { /* Kebab menu icon itself */
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 20px; /* Intrinsic size */
    width: 24px;  /* Intrinsic size */
    padding: 2px;
    font-weight: normal; /* Ensure not bold */
  }
  .menu-icon .dot {
    width: 5px;
    height: 5px;
    background-color: #555;
    border-radius: 50%;
  }

  /* Unified menu & modal item style */
  #dropdown-menu, .modal {
    background-color: #ffffff;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  #dropdown-menu {
    position: absolute;
    top: 30px; /* Adjusted based on menu icon position */
    right: 0;
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
    transform-origin: top right;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    z-index: 1000;
    pointer-events: none;
    min-width: 200px;
  }
  #dropdown-menu.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
  }
  .dropdown-item, .modal-item { /* Removed .cat-item */
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    font-size: 0.95rem;
    user-select: none;
    background-color: #fff;
    color: #333;
    transition: background-color 0.15s ease;
  }
   .modal-item { /* Specific for profile/category list items */
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .preset-item { /* This class is no longer used for list items in the modal */
    padding: 5px 10px;
    cursor: pointer;
    font-size: 0.9rem;
    user-select: none;
    color: #333;
    transition: background-color 0.15s ease;
    border-radius: 4px;
    border: 1px solid #d1d5db;
    background-color: #f9f9f9;
  }
  .preset-item:disabled {
    opacity: 0.6;
    cursor: default;
    background-color: #e9ecef;
  }
  .dropdown-item:last-child, .modal-item:last-child { /* Removed .cat-item */
    border-bottom: none;
  }
  .dropdown-item:hover, .modal-item:hover, .preset-item:hover:not(:disabled) { /* Removed .cat-item */
    background-color: #f0f0f0;
  }

  /* Progress & Headline */
  #progress-container {
    margin-bottom: 20px;
  }
  #progress-bar {
    height: 12px;
    width: 100%;
    background-color: #e9ecef;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.075);
  }
  #progress-fill {
    height: 100%;
    width: 0;
    background: linear-gradient(to right, cyan, magenta, yellow);
    transition: width 0.4s ease-in-out;
    border-radius: 6px;
  }
  #progress-label {
    text-align: right;
    font-size: 0.9rem;
    margin-top: 6px;
    color: #555;
  }
  .view-headline {
    font-size: 1.3rem;
    margin: 15px 0 20px; /* Original spacing from content */
    text-align: center;
    color: #333;
    font-weight: 500;
  }

  /* Profile Selector Styling */
  #profile-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 5px 0 15px;
  }
  #profile-select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: transparent;
    border: none;
    padding: 5px 8px;
    font-size: 1.1rem;
    font-weight: normal;
    cursor: pointer;
    outline: none;
    margin: 0;
    text-align: center;
    text-align-last: center;
    text-decoration: underline;
    color: #555;
  }
  #profile-select::-ms-expand {
    display: none;
  }


  /* Sections and rows */
  .section-header {
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #e9ecef;
    padding: 10px 15px;
    border-radius: 6px;
    margin-top: 15px;
    transition: background-color 0.2s ease;
  }
  .section-header:hover {
    background-color: #dce2e8;
  }
  .section-header h2 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 500;
    color: #333;
  }
  .section-header span { /* For + / - icons */
    font-size: 0.85rem;
    font-weight: bold;
    color: #777;
    display: inline-block;
    min-width: 1.5em;
    text-align: center;
    line-height: 1;
  }
  .section-content {
    margin-top: 10px;
    padding-left: 5px;
  }
  .exercise-row {
    display: flex;
    flex-direction: column;
    background-color: #fff;
    padding: 12px 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.07);
    border: 1px solid #e7e7e7;
    transition: box-shadow 0.2s ease;
  }
  .exercise-row:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  .exercise-row .header-row {
    display: flex;
    justify-content: space-between; /* Keeps name and edit button apart */
    align-items: center;
    margin-bottom: 6px;
  }
  .exercise-row .name {
    font-size: 1.05rem;
    font-weight: 500;
    color: #222;
    /* Removed flex properties - headerRow handles spacing */
  }

  .reps-duration { /* This class now styles the combined weight/reps/duration line */
    color: #777;
    font-size: 0.9rem;
    margin-top: 4px;
    margin-bottom: 8px;
  }


  .weekday-row {
    display: flex;
    align-items: center;
    margin-top: 6px;
    padding: 4px 0;
  }
  .weekday-label {
    color: #444;
    font-size: 0.9rem;
    width: 70px;
    font-weight: 500;
  }
  .checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-left: 8px;
  }
  .checkbox-container {
    display: flex;
    align-items: center;
  }
  .edit-button {
    color: #777;
    font-size: 0.85rem;
    font-weight: 400;
    background-color: transparent;
    border: none;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s ease, color 0.2s ease;
  }
  .edit-button:hover {
    background-color: #e6f2ff;
    color: #007bff;
  }

  /* Buttons */
  .app-button {
    padding: 12px 18px;
    font-size: 1rem;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    width: 100%;
    margin-top: 15px;
    transition: opacity 0.2s ease, transform 0.1s ease;
    text-align: center;
  }
  .app-button:hover {
    opacity: 0.85;
  }
  .app-button:active {
    transform: translateY(1px);
  }

  .add-button {
    background-color: #00BFFF;
    color: #FFFFFF;
  }
  .reset-button {
    background-color: magenta;
    color: #fff;
  }

  /* Modal specifics */
  .modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background-color: rgba(0,0,0,0.5);
    z-index: 998; display: none;
  }
  .modal-overlay.active { display: block; }
  .modal {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    padding: 20px 25px;
    z-index: 999; width: 90%; max-width: 450px;
    max-height: 90vh; overflow-y: auto; display: none;
    opacity: 0; transition: opacity 0.25s ease-out, transform 0.25s ease-out;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
  }
  .modal.active {
    display: block; opacity: 1; transform: translate(-50%, -50%) scale(1);
  }
  .modal h3 {
    margin-top: 0; margin-bottom: 20px;
    font-size: 1.4rem; color: #333;
    text-align: center; font-weight: 500;
  }
  .modal-label {
    display: block; margin-bottom: 6px; font-size: 0.9rem;
    color: #444; font-weight: 500;
  }
  .modal-input, .modal-number, .modal-select {
    width: 100%; padding: 10px 12px; margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1rem; height: auto;
    background-color: #fff;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  /* Input field used for renaming in lists */
  .list-rename-input {
    margin-bottom: 0 !important; /* Override .modal-input margin */
    flex-grow: 1;
  }

  .modal-input:focus, .modal-number:focus, .modal-select:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
    outline: none;
  }
  #ex-cat { /* Select for exercise category */
    appearance: none;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3csvg%3e");
    background-repeat: no-repeat; background-position: right .75rem center; background-size: 16px 12px;
  }

  .modal-actions {
    display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;
  }
  .modal-button {
    padding: 10px 18px; font-size: 0.95rem; font-weight: 500;
    border: none; border-radius: 6px; cursor: pointer;
    transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
  }
   .modal-button:active { transform: translateY(1px); }
  .modal-button.save { background-color: #00BFFF; color: #fff; }
  .modal-button.cancel { background-color: #6c757d; color: #fff; }

  .modal-button.delete {
    background-color: magenta;
    color: #fff;
    padding: 8px 12px;
    font-size: 1.1rem;
    font-weight: bold;
    line-height: 1;
    min-width: auto;
    margin-right: auto; /* For main modal delete button like exercise delete */
  }
  /* Smaller buttons inside lists (profile/category rename/delete) */
  .modal-item .modal-button {
    padding: 6px 10px;
    font-size: 0.85rem;
  }
  .modal-item .modal-button.delete { /* 'x' delete button in lists */
     margin-right: 0;
     padding: 6px 10px;
     font-size: 1rem;
  }

  .modal-button.delete:hover, .modal-button.save:hover, .modal-button.cancel:hover {
    opacity: 0.85;
  }

  #add-profile-btn, #add-cat-btn { /* Specific Add buttons in modals */
    background-color: #00BFFF;
    color: #FFFFFF;
  }

  /* --- DRAG & DROP & CATEGORY MANAGEMENT START --- */
  #cat-list, #profile-list { /* Removed #preset-list */
    margin-top: 10px; margin-bottom: 20px;
  }

  #cat-list .modal-item {
      cursor: grab; /* Indicate draggable item */
      position: relative; /* Needed for drag-over effect */
      z-index: 1; /* Ensure items are above potential drag indicators */
  }

  #cat-list .modal-item.dragging {
      opacity: 0.5; /* Make the item being dragged semi-transparent */
  }

  #cat-list .modal-item.drag-over-before {
      border-top: 2px dashed #007bff; /* Visual cue for drop target */
  }

   #cat-list .modal-item.drag-over-after {
      border-bottom: 2px dashed #007bff; /* Visual cue for drop target */
  }
  /* --- DRAG & DROP & CATEGORY MANAGEMENT END --- */


  #schedule-inputs {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px; margin-top: 10px; margin-bottom: 15px;
  }
  #schedule-inputs .modal-label { margin-bottom: 4px; font-size: 0.85rem; }
  #schedule-inputs .modal-number { margin-bottom: 0; text-align: center; }

  /* Custom style for grey zero */
  .modal-number.grey-zero {
    color: #aaa; /* Light grey color */
  }
  .modal-number:focus.grey-zero {
    color: #333; /* Change back to normal text color on focus */
  }

  /* Style for reps/duration input group */
  .reps-duration-input-group {
    display: flex;
    align-items: center; /* Vertically center items in the flex container */
    gap: 10px; /* Space between inputs and 'or' */
    margin-bottom: 15px;
  }
   .reps-duration-input-group > span {
       align-self: center; /* Explicitly center the 'or' text itself */
       font-size: 0.9rem;
       color: #555;
       flex-shrink: 0; /* Prevent 'or' from shrinking */
       padding-top: 18px; /* Add padding to align 'or' with the bottom of labels */
   }
  .reps-duration-input-group .modal-input,
  .reps-duration-input-group .modal-number {
    margin-bottom: 0; /* Remove bottom margin when in group */
  }
  .reps-duration-input-group .input-container {
      flex-grow: 1; /* Allow inputs to grow */
  }
  .reps-duration-input-group .input-container label {
      display: block; /* Ensure label is above input */
      margin-bottom: 4px; /* Space between label and input */
      font-size: 0.85rem; /* Smaller label font */
      color: #444;
      font-weight: 500;
  }


</style>
</head>
<body>
  <div class="header-container">
    <div></div> <div class="logo-container">Training Arc</div>
    <div class="menu-container">
      <div class="menu-icon" onclick="toggleMenu()">
        <div class="dot"></div><div class="dot"></div><div class="dot"></div>
      </div>
      <div id="dropdown-menu">
        <div class="dropdown-item" onclick="toggleViewMode()">Toggle View Mode</div>
        <div class="dropdown-item" onclick="openProfileModal()">Manage Profiles</div>
        <div class="dropdown-item" onclick="openCatModal()">Manage Categories</div>
        <div class="dropdown-item" onclick="exportExercises()">Export Exercises</div>
        <div class="dropdown-item" onclick="importExercises()">Import Exercises</div>
        <div class="dropdown-item" onclick="clearExercises()">Clear All Exercises</div>
        <div class="dropdown-item" onclick="showAbout()">About</div>
      </div>
    </div>
  </div>

  <div id="progress-container">
    <div id="progress-bar"><div id="progress-fill"></div></div>
    <div id="progress-label">0%</div>
  </div>

  <div id="view-headline" class="view-headline"></div>

  <div id="profile-container">
    <select id="profile-select" onchange="switchProfile()"></select>
  </div>

  <div id="tracker-content"></div>

  <button class="app-button add-button" id="add-exercise-btn">Add New Exercise</button>
  <button class="app-button reset-button" id="reset-btn">Reset Weekly Progress</button>

  <div class="modal-overlay" id="modal-overlay"></div>
  <div class="modal" id="modal">
    <h3 id="modal-title-ex">Add/Edit Exercise</h3>
    <label class="modal-label" for="ex-name">Exercise Name</label>
    <input class="modal-input" type="text" id="ex-name" placeholder="e.g., Push-ups" />
    <label class="modal-label" for="ex-cat">Category</label>
    <select class="modal-input modal-select" id="ex-cat"></select>

    <label class="modal-label" for="ex-weight-num">Weight</label>
    <input class="modal-number modal-input" type="number" min="0" id="ex-weight-num" placeholder="e.g., 50" />


    <div class="reps-duration-input-group">
        <div class="input-container">
            <label for="ex-reps-num">Reps</label> <input class="modal-number modal-input" type="number" min="0" id="ex-reps-num" placeholder="e.g., 10" />
        </div>
        <span>or</span>
        <div class="input-container">
             <label for="ex-duration-text">Duration</label> <input class="modal-input" type="text" id="ex-duration-text" placeholder="e.g., 30s" /> </div>
    </div>


    <label class="modal-label">Sets per Weekday</label>
    <div id="schedule-inputs"></div>
    <div class="modal-actions">
      <button class="modal-button delete" id="delete-btn" style="display:none;">x</button> <button class="modal-button cancel" onclick="closeModal()">Cancel</button>
      <button class="modal-button save" id="save-btn">Save</button>
    </div>
  </div>

  <div class="modal-overlay" id="profile-modal-overlay"></div>
  <div class="modal" id="profile-modal">
    <h3>Manage Profiles</h3>
    <div id="profile-list"></div>
    <input type="text" id="new-profile-name-input" class="modal-input" placeholder="New profile name" style="margin-top: 15px; margin-bottom:10px;">
    <button class="modal-button save" id="add-profile-btn" style="width:100%; margin-bottom:10px;">Add Profile</button>
    <div class="modal-actions" style="justify-content: flex-end;">
        <button class="modal-button cancel" onclick="closeProfileModal()">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="cat-modal-overlay"></div>
  <div class="modal" id="cat-modal">
    <h3>Manage Categories</h3>
    <label class="modal-label">Drag to reorder. Click 'x' to remove (not possible for original presets).</label> <div id="cat-list"></div> <input type="text" id="new-category-name-input" class="modal-input" placeholder="Add new category..." style="margin-top: 15px; margin-bottom:10px;">
    <button class="modal-button save" id="add-cat-btn" style="width:100%; margin-bottom:10px;">Add Category</button> <div class="modal-actions" style="justify-content: flex-end;">
      <button class="modal-button cancel" onclick="closeCatModal()">Close</button>
      </div>
  </div>

<script>
    const WEEKDAYS=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
    const ORIGINAL_PRESET_CATEGORIES=["Daily GTG","Upper Body","Lower Body","Mobility","Core","Conditioning","Skills"]; // Keep original presets separate
    let exercises=[], collapsedCategories={}, editIndex=null;
    let isWeekly=true;

    // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
    let categoryOrder = []; // This will hold the current order of ALL categories
    let dragStartIndex = -1; // For drag and drop

    function loadCategoryOrder() {
        try {
            const storedOrder = localStorage.getItem('categoryOrder');
            if (storedOrder) {
                 categoryOrder = JSON.parse(storedOrder);
                 // Migration or cleanup: ensure categoryOrder only contains strings and no duplicates
                 categoryOrder = Array.from(new Set(categoryOrder.filter(item => typeof item === 'string')));

                 // Ensure all original presets are included if they somehow got removed, append them to the end
                 const currentOrderLower = categoryOrder.map(cat => cat.toLowerCase());
                 ORIGINAL_PRESET_CATEGORIES.forEach(preset => {
                     if (!currentOrderLower.includes(preset.toLowerCase())) {
                         categoryOrder.push(preset);
                     }
                 });

            } else {
                // Initial load: Create order from old customCategories (if any) and presets
                const oldCustomCategories = JSON.parse(localStorage.getItem('customCategories')) || [];
                 // Start with old custom categories, then add presets not already in custom
                categoryOrder = [...oldCustomCategories, ...ORIGINAL_PRESET_CATEGORIES.filter(p => !oldCustomCategories.map(c => c.toLowerCase()).includes(p.toLowerCase()))];
                 // Remove old customCategories from storage after migration
                 localStorage.removeItem('customCategories');
            }
        } catch(e) {
            console.error("Error loading category order:", e);
            categoryOrder = [...ORIGINAL_PRESET_CATEGORIES]; // Fallback to just presets
        }
         saveCategoryOrderToStorage(); // Save the potentially new or corrected order immediately
         console.log("Loaded/Initial Category Order:", categoryOrder); // Log for debugging
    }

     function saveCategoryOrderToStorage() {
        localStorage.setItem('categoryOrder', JSON.stringify(categoryOrder));
         console.log("Saved Category Order:", categoryOrder); // Log for debugging
    }

    // This function now just returns the loaded/saved order
    function allCategories(){ return [...categoryOrder]; } // Return a copy
    // --- DRAG & DROP & CATEGORY MANAGEMENT END ---

    function toggleMenu(){ document.getElementById('dropdown-menu').classList.toggle('show'); }
    function toggleViewMode(){ isWeekly=!isWeekly; localStorage.setItem('isWeeklyView', isWeekly); document.getElementById('dropdown-menu').classList.remove('show'); renderExercises(); } // Save view mode here

    function exportExercises(){
        toggleMenu();
        if (exercises.length === 0 && categoryOrder.length === 0) { // Check categoryOrder too
            alert("No exercises or categories to export for the current profile.");
            return;
        }
        const profileName = currentProfile; // Use the actual profile name from the app

        // --- Code to truncate and sanitize profile name for filename ---
        const MAX_FILENAME_PROFILE_LENGTH = 40; // Keep the max length limit
        let truncatedProfileName = profileName.length > MAX_FILENAME_PROFILE_LENGTH
            ? profileName.substring(0, MAX_FILENAME_PROFILE_LENGTH)
            : profileName;

        // Sanitize the profile name for filename compatibility (remove spaces, remove illegal chars)
        // Removing spaces to meet the 'no space in between' requirement for the entire filename
        const sanitizedProfileName = truncatedProfileName.replace(/[\s]/g, '').replace(/[^a-zA-Z0-9_\-.]/g, '');
        // --- End truncation and sanitization code ---

        const exportData = {
            profileName: currentProfile, // Keep the original, full name inside the file data
            exercises: exercises,
            categoryOrder: categoryOrder, // Export the category order
            viewSettings: {
                 isWeekly: isWeekly,
                 // Also export the collapsed state for the current profile
                 collapsedCategories: JSON.parse(localStorage.getItem('collapsedCategories_' + currentProfile)) || {}
            }
        };

        const a=document.createElement('a');
        a.href='data:text/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(exportData));

        // --- Modified Filename Format: ProfilenameYYMMDD.json ---
        const now = new Date();
        const year = now.getFullYear().toString().slice(-2); // Get last 2 digits of year
        const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Get month (0-11) and pad
        const day = now.getDate().toString().padStart(2, '0'); // Get day and pad
        const yymmdd = `${year}${month}${day}`; // Combine into YYMMDD

        a.download= `${sanitizedProfileName}${yymmdd}.json`; // Combine sanitized name and YYMMDD directly
        // --- End Modified Filename Format ---

        a.click();
    }

    function importExercises(){
        toggleMenu();
        const inp=document.createElement('input');
        inp.type='file';
        inp.accept='application/json';
        inp.onchange=e=>{
            const f=e.target.files[0];
            if(!f)return;
            const r=new FileReader();
            r.onload=()=>{
                try {
                    const importedData = JSON.parse(r.result);
                    if (importedData && importedData.exercises && Array.isArray(importedData.exercises)) {
                        let importToProfile = currentProfile;
                        let newProfileCreated = false;
                        let profileSwitchConfirmed = false;

                        if (importedData.profileName) {
                            if (!profiles[importedData.profileName]) {
                                if (confirm(`Imported data is for profile "${importedData.profileName}". Create this profile and import data into it?`)) {
                                    profiles[importedData.profileName] = [];
                                    importToProfile = importedData.profileName;
                                    newProfileCreated = true;
                                    profileSwitchConfirmed = true;
                                } else if (confirm(`Import into current profile "${currentProfile}" instead? This will overwrite existing data for "${currentProfile}".`)){
                                    profileSwitchConfirmed = true;
                                } else { return; }
                            } else if (importedData.profileName !== currentProfile) {
                                if (confirm(`Imported data is for profile "${importedData.profileName}". Switch to this profile and overwrite its data?`)) {
                                    importToProfile = importedData.profileName;
                                    profileSwitchConfirmed = true;
                                } else if (confirm(`Import into current profile "${currentProfile}" instead? This will overwrite existing data for "${currentProfile}".`)) {
                                    profileSwitchConfirmed = true;
                                } else { return; }
                            } else {
                                if (!confirm(`This will overwrite all exercises in the current profile "${currentProfile}". Continue?`)) { return; }
                                profileSwitchConfirmed = true;
                            }
                        } else {
                             if (!confirm(`No profile name in import file. Import exercises into current profile "${currentProfile}"? This will overwrite existing data.`)) { return; }
                            profileSwitchConfirmed = true;
                        }

                        if (!profileSwitchConfirmed) return;

                        // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
                        // Handle imported category order
                        if (importedData.categoryOrder && Array.isArray(importedData.categoryOrder)) {
                             if (confirm(`Imported data includes a custom category order. Use this order and merge in any new categories?`)) {
                                 const importedOrder = importedData.categoryOrder.filter(item => typeof item === 'string');
                                 const currentOrderLower = categoryOrder.map(c => c.toLowerCase());

                                 // Add imported categories that are not currently present
                                 importedOrder.forEach(importedCat => {
                                     if (!currentOrderLower.includes(importedCat.toLowerCase())) {
                                         categoryOrder.push(importedCat); // Add new ones to the end initially
                                     }
                                 });

                                 // Now reorder categoryOrder based on the importedOrder sequence
                                 const newCategoryOrder = importedOrder.filter(cat => categoryOrder.map(c => c.toLowerCase()).includes(cat.toLowerCase())); // Start with existing categories from import
                                  // Add any existing categories not in the import to the end
                                  categoryOrder.forEach(currentCat => {
                                      if (!newCategoryOrder.map(c => c.toLowerCase()).includes(currentCat.toLowerCase())) {
                                          newCategoryOrder.push(currentCat);
                                      }
                                  });
                                 categoryOrder = newCategoryOrder; // Apply the merged and reordered list

                                 saveCategoryOrderToStorage(); // Save the merged/reordered categories
                                 populateCatModal(); // Refresh modal if open
                                 populateExerciseCategoryDropdown(); // Update dropdown
                             } else {
                                  // User chose not to use imported order, keep current categoryOrder state
                                  // Still need to ensure imported exercises' categories exist in categoryOrder
                                   importedData.exercises.forEach(ex => {
                                       if (ex.category) {
                                           const catExists = categoryOrder.some(c => c.toLowerCase() === ex.category.toLowerCase());
                                           if (!catExists) {
                                                if (confirm(`The exercise "${ex.name}" uses category "${ex.category}" which is not in your list. Add "${ex.category}"?`)) {
                                                     categoryOrder.push(ex.category); // Add new exercise category to the end
                                                     saveCategoryOrderToStorage();
                                                     populateCatModal();
                                                     populateExerciseCategoryDropdown();
                                                }
                                           }
                                       }
                                   });
                             }
                        } else {
                             // No categoryOrder in import, just ensure exercise categories exist
                             importedData.exercises.forEach(ex => {
                                if (ex.category) {
                                    const catExists = categoryOrder.some(c => c.toLowerCase() === ex.category.toLowerCase());
                                    if (!catExists) {
                                         if (confirm(`The exercise "${ex.name}" uses category "${ex.category}" which is not in your list. Add "${ex.category}"?`)) {
                                             categoryOrder.push(ex.category); // Add new exercise category to the end
                                             saveCategoryOrderToStorage();
                                             populateCatModal();
                                             populateExerciseCategoryDropdown();
                                         }
                                    }
                                }
                             });
                        }
                        // --- DRAG & DROP & CATEGORY MANAGEMENT END ---


                        currentProfile = importToProfile;
                        localStorage.setItem("currentProfile", currentProfile);
                        exercises = importedData.exercises.map(ensureScheduleFormat);
                        profiles[currentProfile] = exercises;
                        localStorage.setItem("profiles", JSON.stringify(profiles));

                        if (newProfileCreated || importedData.profileName !== document.getElementById("profile-select").value) {
                            loadProfileOptions();
                        }
                        document.getElementById('profile-select').value = currentProfile;

                        if (importedData.viewSettings && typeof importedData.viewSettings.isWeekly === 'boolean') {
                            isWeekly = importedData.viewSettings.isWeekly;
                             localStorage.setItem('isWeeklyView', isWeekly); // Save imported view mode
                        }
                         // Restore collapsed state from imported data if available, save to profile-specific key
                         if (importedData.viewSettings && importedData.viewSettings.collapsedCategories) {
                              collapsedCategories = importedData.viewSettings.collapsedCategories;
                              localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                         } else {
                              // If imported data doesn't have collapsed state, load current profile's state
                              try {
                                  collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories_' + currentProfile)) || {};
                              } catch (e) {
                                   console.error("Error loading collapsed state during import fallback for profile", currentProfile, e);
                                   collapsedCategories = {}; // Fallback to empty
                              }
                         }

                        renderExercises();
                        // populateExerciseCategoryDropdown(); // Called during category import handling
                        alert("Data imported successfully to profile: " + currentProfile + "!");
                    } else { alert("Invalid file format. Expected 'exercises' array."); }
                } catch (err) { alert("Error importing file: " + err.message); console.error("Import error:", err); }
            };
            r.readAsText(f);
        };
        inp.click();
    }

    function clearExercises(){
        toggleMenu();
        // console.log("Clear exercises initiated for profile:", currentProfile); // Removed debug log
        if (exercises.length === 0) {
            alert("No exercises to clear.");
            return;
        }
        if(confirm(`Are you sure you want to clear all exercises for the current profile "${currentProfile}"? This cannot be undone.`)){
            exercises=[]; // Clears the in-memory exercises array
            // console.log("Exercises array after clearing:", exercises); // Removed debug log
            saveExercises(); // Saves the empty exercises array
            renderExercises(); // Re-renders the display
        }
    }
    function openCatModal(){
        document.getElementById('dropdown-menu').classList.remove('show');
        document.getElementById('cat-modal-overlay').classList.add('active');
        document.getElementById('cat-modal').classList.add('active');
        populateCatModal();
    }
    function closeCatModal(){
        document.getElementById('cat-modal-overlay').classList.remove('active');
        document.getElementById('cat-modal').classList.remove('active');
        populateExerciseCategoryDropdown(); // Refresh dropdown in case categories changed
        renderExercises(); // Refresh main view in case order changed
    }
    function showAbout(){
        toggleMenu();
        alert('Training Arc - GtG Loop Tracker\n\nBeta Version 1.2 (UI & Management Overhaul)\nA loop tracker for daily habits.\nProgress is saved locally.\n\nby Sascha Leng');
    }

    // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
    function populateCatModal() {
        const list = document.getElementById('cat-list');
        list.innerHTML = '';

        if (categoryOrder.length === 0) {
             list.innerHTML = `<p style="text-align:center; color:#777; margin-top:10px;">No categories defined. Add one below!</p>`;
             return;
        }

        categoryOrder.forEach((catName) => { // Iterate directly over the order array
            const originalCategoryName = catName; // For closure

            const item = document.createElement('div');
            item.className = 'modal-item';
            item.setAttribute('draggable', true); // Make the item draggable
            item.setAttribute('data-name', originalCategoryName); // Store the category name for drag/drop

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalCategoryName;
            nameSpan.style.flexGrow = "1";

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'modal-input list-rename-input';
            nameInput.value = originalCategoryName;
            nameInput.style.display = 'none';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.className = 'modal-button';

            const saveRenameBtn = document.createElement('button');
            saveRenameBtn.textContent = 'Save';
            saveRenameBtn.className = 'modal-button save';
            saveRenameBtn.style.display = 'none';

            const cancelRenameBtn = document.createElement('button');
            cancelRenameBtn.textContent = 'Cancel';
            cancelRenameBtn.className = 'modal-button cancel';
            cancelRenameBtn.style.display = 'none';

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'x';
            deleteBtn.className = 'modal-button delete';
            // Disable delete for original preset categories
            deleteBtn.disabled = ORIGINAL_PRESET_CATEGORIES.map(p => p.toLowerCase()).includes(originalCategoryName.toLowerCase());


            const controlsDiv = document.createElement('div');
            controlsDiv.style.display = 'flex';
            controlsDiv.style.alignItems = 'center';
            controlsDiv.style.gap = '8px';
            controlsDiv.appendChild(renameBtn);
            controlsDiv.appendChild(saveRenameBtn);
            controlsDiv.appendChild(cancelRenameBtn);
            controlsDiv.appendChild(deleteBtn);

            item.appendChild(nameSpan);
            item.appendChild(nameInput);
            item.appendChild(controlsDiv);
            list.appendChild(item);

            nameInput.onfocus = () => { item.setAttribute('draggable', false); };
            nameInput.onblur = () => { item.setAttribute('draggable', true); };


            renameBtn.onclick = () => {
                 // Disable dragging while editing
                 item.setAttribute('draggable', false);
                nameSpan.style.display = 'none';
                nameInput.style.display = 'block'; nameInput.style.flexGrow = '1';
                nameInput.value = nameSpan.textContent; nameInput.focus();
                renameBtn.style.display = 'none';
                saveRenameBtn.style.display = 'inline-block';
                cancelRenameBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            };

            cancelRenameBtn.onclick = () => {
                 // Re-enable dragging
                 item.setAttribute('draggable', true);
                nameSpan.style.display = 'block';
                nameInput.style.display = 'none';
                renameBtn.style.display = 'inline-block';
                saveRenameBtn.style.display = 'none';
                cancelRenameBtn.style.display = 'none';
                deleteBtn.style.display = 'inline-block';
            };

            saveRenameBtn.onclick = () => {
                const newNameTrimmed = nameInput.value.trim();
                if (!newNameTrimmed) {
                    alert("Category name cannot be empty."); nameInput.focus(); return;
                }
                const newNameLower = newNameTrimmed.toLowerCase();
                const originalNameLower = originalCategoryName.toLowerCase();

                if (newNameLower === originalNameLower && newNameTrimmed === originalCategoryName) {
                    cancelRenameBtn.onclick(); return; // No change
                }

                 // Check for conflicts in the *entire* categoryOrder list
                const conflict = categoryOrder.some(cat => cat.toLowerCase() === newNameLower && cat.toLowerCase() !== originalNameLower);

                if (conflict) {
                    alert(`Category name "${newNameTrimmed}" already exists.`);
                    nameInput.focus(); return;
                }

                // Update exercises using the old category name
                exercises.forEach(ex => {
                    if (ex.category === originalCategoryName) {
                        ex.category = newNameTrimmed;
                    }
                });
                saveExercises(); // Save exercises with updated category names

                // Update the categoryOrder array by finding the old name and replacing it
                const oldIndex = categoryOrder.indexOf(originalCategoryName);
                if(oldIndex !== -1) {
                    categoryOrder[oldIndex] = newNameTrimmed;
                    saveCategoryOrderToStorage();
                    alert(`Category "${originalCategoryName}" renamed to "${newNameTrimmed}".`);
                    populateCatModal(); // Refresh this modal's list
                    // populateExerciseCategoryDropdown and renderExercises called when modal closes
                } else {
                     console.error("Category not found in order array during rename:", originalCategoryName);
                      cancelRenameBtn.onclick(); // Revert UI if not found in array
                }
            };

            deleteBtn.onclick = () => {
                 if (deleteBtn.disabled) {
                     alert("Original preset categories cannot be removed.");
                     return;
                 }
                if (confirm(`Remove category "${originalCategoryName}"? Exercises using this category will need their category reassigned manually later if desired.`)) {
                    // Find the index by name in the current order array
                    const indexToDelete = categoryOrder.indexOf(originalCategoryName);
                    if(indexToDelete !== -1) {
                         categoryOrder.splice(indexToDelete, 1);
                         saveCategoryOrderToStorage();
                         populateCatModal(); // Refresh this modal's list
                         // populateExerciseCategoryDropdown and renderExercises called when modal closes
                    } else {
                         console.error("Category not found in order array for deletion:", originalCategoryName);
                         populateCatModal(); // Just refresh in case of discrepancy
                    }
                }
            };
        });
        document.getElementById('new-category-name-input').value = '';
    }


    document.getElementById('add-cat-btn').onclick=()=>{
        const newCatNameInput = document.getElementById('new-category-name-input');
        const newCatName = newCatNameInput.value.trim();
        if (!newCatName) {
            alert("Please enter a category name."); return;
        }
        const lowerNewCatName = newCatName.toLowerCase();
        // Check for duplicates in the entire categoryOrder list
        if (categoryOrder.map(c=>c.toLowerCase()).includes(lowerNewCatName)) {
            alert(`Category "${newCatName}" already exists.`);
        } else {
            categoryOrder.push(newCatName); // Add to the end
            saveCategoryOrderToStorage();
            populateCatModal(); // Refresh the modal list to show the new item
            // populateExerciseCategoryDropdown and renderExercises called when modal closes
            newCatNameInput.value = '';
        }
    };
    document.getElementById('cat-modal-overlay').onclick=closeCatModal;

    // Drag & Drop Event Listeners on the cat-list container
    const catListElement = document.getElementById('cat-list');

    catListElement.addEventListener('dragstart', (e) => {
        const targetItem = e.target.closest('.modal-item');
        if (!targetItem || !targetItem.draggable) return; // Only drag draggable items

        const categoryName = targetItem.getAttribute('data-name');
        dragStartIndex = categoryOrder.indexOf(categoryName); // Get index from the actual order array

        if (dragStartIndex === -1) { // Should not happen if logic is correct
             e.preventDefault(); return;
        }

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', categoryName); // Pass the category name or index
        targetItem.classList.add('dragging');
    });

    catListElement.addEventListener('dragover', (e) => {
        e.preventDefault(); // Necessary to allow dropping
        e.dataTransfer.dropEffect = 'move';

        const targetItem = e.target.closest('.modal-item');
        // Find the actual item element, not its children, and ensure it's in the list and not the item being dragged
        if (!targetItem || !catListElement.contains(targetItem) || targetItem.classList.contains('dragging')) {
             // Clear drag-over classes if not hovering over a valid target item
             catListElement.querySelectorAll('.modal-item').forEach(item => {
                 item.classList.remove('drag-over-before', 'drag-over-after');
             });
             return;
         }

        // Remove existing drag-over classes from all items
        catListElement.querySelectorAll('.modal-item').forEach(item => {
            item.classList.remove('drag-over-before', 'drag-over-after');
        });

        // Determine if dragging before or after the target item
        const targetRect = targetItem.getBoundingClientRect();
        const targetMiddleY = targetRect.top + targetRect.height / 2;

        if (e.clientY < targetMiddleY) {
            targetItem.classList.add('drag-over-before');
        } else {
             targetItem.classList.add('drag-over-after');
        }
    });

    catListElement.addEventListener('dragleave', (e) => {
         // Only remove class if leaving the list item itself, not just moving within it
         const targetItem = e.target.closest('.modal-item');
         if (targetItem && catListElement.contains(targetItem) && !targetItem.contains(e.relatedTarget)) {
             targetItem.classList.remove('drag-over-before', 'drag-over-after');
         } else if (!catListElement.contains(e.relatedTarget)) {
              // Left the entire list container
             catListElement.querySelectorAll('.modal-item').forEach(item => {
                 item.classList.remove('drag-over-before', 'drag-over-after');
             });
         }
    });


    catListElement.addEventListener('drop', (e) => {
        e.preventDefault();
        const dragItemElement = catListElement.querySelector('.modal-item.dragging'); // The DOM element being dragged
        const targetItemElement = e.target.closest('.modal-item'); // The DOM element being dropped onto

        // Remove drag-over classes from all items
        catListElement.querySelectorAll('.modal-item').forEach(item => {
            item.classList.remove('drag-over-before', 'drag-over-after');
        });

        if (!dragItemElement || !targetItemElement || !catListElement.contains(targetItemElement) || dragItemElement === targetItemElement) return;

        const draggedCategoryName = dragItemElement.getAttribute('data-name');
        const targetCategoryName = targetItemElement.getAttribute('data-name');

        const dragIndex = categoryOrder.indexOf(draggedCategoryName);
        let dropIndex = categoryOrder.indexOf(targetCategoryName);

        if (dragIndex === -1 || dropIndex === -1) { // Should not happen
             console.error("Dragged or target category not found in order array.");
             return;
        }

         // Adjust dropIndex based on whether we're dropping before or after the target
        const targetRect = targetItemElement.getBoundingClientRect();
        const targetMiddleY = targetRect.top + targetRect.height / 2;
        if (e.clientY > targetMiddleY) {
            // Dropping after the target item
            dropIndex++;
        }

        // Ensure dropIndex is not out of bounds after incrementing
         dropIndex = Math.min(dropIndex, categoryOrder.length);


        // Perform the move in the categoryOrder array
        // 1. Remove the dragged item from its original position
        const [movedCategory] = categoryOrder.splice(dragIndex, 1);

        // 2. Insert the dragged item at the new position
        categoryOrder.splice(dropIndex, 0, movedCategory);

        saveCategoryOrderToStorage(); // Save the new order
        populateCatModal(); // Re-render the list to reflect the new order
        // populateExerciseCategoryDropdown() and renderExercises() called when modal closes
    });

    catListElement.addEventListener('dragend', (e) => {
        const dragItem = catListElement.querySelector('.modal-item.dragging');
        if (dragItem) {
            dragItem.classList.remove('dragging');
        }
         // Also ensure drag-over classes are removed on drag end
         catListElement.querySelectorAll('.modal-item').forEach(item => {
             item.classList.remove('drag-over-before', 'drag-over-after');
         });
        dragStartIndex = -1; // Reset drag start index
    });
    // --- DRAG & DROP & CATEGORY MANAGEMENT END ---


    function populateExerciseCategoryDropdown() {
        const catSel = document.getElementById('ex-cat');
        const currentCatValue = catSel.value; // Preserve current selection if possible
        catSel.innerHTML = ''; // Clear existing options

        const categoriesToDisplay = allCategories(); // Use the categoryOrder

        if (categoriesToDisplay.length === 0) {
            catSel.innerHTML = '<option value="">No Categories Available</option>';
             // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
             // Disable the select if no categories
            catSel.disabled = true;
             // --- DRAG & DROP & CATEGEMENT END ---
            return;
        }

         // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
        catSel.disabled = false;
         // --- DRAG & DROP & CATEGEMENT END ---

        categoriesToDisplay.forEach(c => {
            catSel.add(new Option(c, c));
        });

        // Try to reselect previous value, or first if not found
        if (categoriesToDisplay.map(c => c.toLowerCase()).includes(currentCatValue.toLowerCase())) {
            const actualCat = categoriesToDisplay.find(c => c.toLowerCase() === currentCatValue.toLowerCase());
            catSel.value = actualCat;
        } else {
            catSel.selectedIndex = 0; // Default to first
        }
    }

    document.getElementById('delete-btn').onclick=()=>{
        if(editIndex!==null && confirm('Are you sure you want to delete this exercise?')){
            exercises.splice(editIndex,1); saveExercises(); closeModal(); renderExercises();
        }
    };

    function openModal(idx=null){
        editIndex=idx;
        document.getElementById('modal-overlay').classList.add('active');
        document.getElementById('modal').classList.add('active');
        const nameInput=document.getElementById('ex-name');
        const catSel=document.getElementById('ex-cat');
        const weightNumInput=document.getElementById('ex-weight-num'); // New weight input
        const repsNumInput=document.getElementById('ex-reps-num'); // New reps input
        const durationTextInput=document.getElementById('ex-duration-text'); // New duration input

        const modalTitle = document.getElementById('modal-title-ex');

        populateExerciseCategoryDropdown(); // Ensure dropdown is fresh

        if(idx!==null){ // Editing existing exercise
            modalTitle.textContent = "Edit Exercise";
            const ex=exercises[idx];
            nameInput.value=ex.name;

            // Set category, handle if category was renamed/deleted
            const currentExerciseCategory = ex.category || "";
            const availableCategories = allCategories(); // Use the categoryOrder
            const categoryExists = availableCategories.some(c => c.toLowerCase() === currentExerciseCategory.toLowerCase());

            if (categoryExists) {
                const actualCat = availableCategories.find(c => c.toLowerCase() === currentExerciseCategory.toLowerCase());
                catSel.value = actualCat;
            } else if (availableCategories.length > 0) {
                catSel.selectedIndex = 0; // Default to first if current doesn't exist
                // Optionally alert user: alert(`Category "${currentExerciseCategory}" no longer exists. Please select a new one.`);
            } else {
                // catSel already shows "No Categories Available" from populateExerciseCategoryDropdown
            }

            // Populate new weight field
            weightNumInput.value = (ex.weight !== undefined && ex.weight !== null) ? ex.weight : ''; // Use new weight property

            // Populate new reps/duration fields
            repsNumInput.value = (ex.reps !== undefined && ex.reps !== null) ? ex.reps : ''; // Use new reps property
            durationTextInput.value = (ex.duration !== undefined && ex.duration !== null) ? ex.duration : ''; // Use new duration property


            document.getElementById('delete-btn').style.display='inline-block';
        } else { // Adding new exercise
            modalTitle.textContent = "Add Exercise";
            nameInput.value='';
            if (allCategories().length > 0) catSel.selectedIndex = 0;
            // else catSel shows "No Categories Available"
            weightNumInput.value = ''; // Clear new weight input
            repsNumInput.value = ''; // Clear new reps input
            durationTextInput.value = ''; // Clear new duration input
            document.getElementById('delete-btn').style.display='none';
        }

        const schedDiv=document.getElementById('schedule-inputs');
        schedDiv.innerHTML='';
        WEEKDAYS.forEach((day,i)=>{
            const dayContainer = document.createElement('div');
            const lbl=document.createElement('label');
            lbl.className='modal-label'; lbl.textContent=day; lbl.htmlFor = `sch_${i}`;
            const num=document.createElement('input');
            num.type='number'; num.min='0'; num.max='20';
            num.className='modal-number modal-input'; num.id=`sch_${i}`;
            // Get scheduled sets for this day, default to 0
            const scheduledSets = (idx!==null && exercises[idx].schedule && exercises[idx].schedule[i]) ? exercises[idx].schedule[i] : 0;
            num.value = scheduledSets;

            // Add grey-zero class if value is 0
            if (parseInt(num.value) === 0) { // Check parsed value just in case input starts with non-numeric leading chars (though type="number" prevents this)
                num.classList.add('grey-zero');
            }


            // Add event listeners for grey-zero behavior
            num.addEventListener('focus', function() {
                this.classList.remove('grey-zero'); // Remove grey class on focus
                 // If value is 0, select the text to make typing over it easy
                 if (parseInt(this.value) === 0) {
                     this.select();
                 }
            });

            num.addEventListener('blur', function() {
                // If value is empty or parsed as 0, set to "0" and add grey class
                const val = parseInt(this.value);
                if (this.value.trim() === '' || isNaN(val) || val <= 0) {
                     this.value = 0;
                    this.classList.add('grey-zero');
                } else {
                     // Ensure value is a positive number, remove grey class
                    this.value = val; // Set value to the parsed integer to clean it up
                    this.classList.remove('grey-zero');
                }
            });

             num.addEventListener('input', function() {
                // Remove grey class if user starts typing a non-zero number
                const val = parseInt(this.value);
                if (!isNaN(val) && val > 0) {
                    this.classList.remove('grey-zero');
                } else if (this.value.trim() === '0') {
                     this.classList.add('grey-zero');
                 }
                 // If input becomes empty (e.g., backspace), the blur listener will handle setting back to 0
            });


            dayContainer.appendChild(lbl); dayContainer.appendChild(num);
            schedDiv.appendChild(dayContainer);
        });
    }
    function closeModal(){
        document.getElementById('modal-overlay').classList.remove('active');
        document.getElementById('modal').classList.remove('active');
        editIndex = null;
    }
    document.getElementById('add-exercise-btn').onclick=()=>openModal(null);
    document.getElementById('modal-overlay').onclick=closeModal;

    document.getElementById('save-btn').onclick=()=>{
        const name=document.getElementById('ex-name').value.trim();
        if(!name){ alert("Please enter an exercise name."); return; }
        const category=document.getElementById('ex-cat').value;
        if(!category || category === "" || category === "No Categories Available"){ alert("Please select or create a category."); return; }

        // Get value from new weight field
        const weightNumValue = parseFloat(document.getElementById('ex-weight-num').value); // Use parseFloat for potentially decimal weights
        let weight = null;
        if (!isNaN(weightNumValue) && weightNumValue >= 0) { // Allow saving 0 weight
             weight = weightNumValue;
        }


        // Get values from new reps/duration fields
        const repsNumValue = parseInt(document.getElementById('ex-reps-num').value);
        const durationTextValue = document.getElementById('ex-duration-text').value.trim();

        let reps = null;
        let duration = null;

        // Determine whether to save reps or duration
        if (!isNaN(repsNumValue) && repsNumValue >= 0) { // Allow saving 0 reps
            reps = repsNumValue;
            duration = null; // Ensure duration is null if reps is set
        } else if (durationTextValue !== '') {
            duration = durationTextValue;
            reps = null; // Ensure reps is null if duration is set
        }

        // Optional: Alert if neither weight, reps nor duration is entered?
        // if (weight === null && reps === null && duration === null) {
        //     alert("Please enter weight, reps, or duration.");
        //     return;
        // }


        const sched={};
        WEEKDAYS.forEach((_,i)=>{
            const valInput = document.getElementById(`sch_${i}`);
            if (valInput) {
                // Use the potentially greyed value, parse as int
                const v=parseInt(valInput.value)||0; // parseInt("") is NaN, ||0 handles this
                if(v>0) sched[i]=v;
            }
        });
        if(Object.keys(sched).length === 0 && !confirm("This exercise has no scheduled days. Save anyway?")) return;

        // Save with new weight, reps, duration properties
        const obj={name,category,weight,reps,duration,schedule:sched,progress:{}};

        if(editIndex!==null) exercises[editIndex]=obj;
        else exercises.push(obj);
        saveExercises(); closeModal(); renderExercises();
    };
    document.getElementById('reset-btn').onclick=()=>{
        if (exercises.length === 0) { alert("No exercises to reset."); return; }
        if(confirm('Are you sure you want to reset all progress for the current profile?')){
            exercises.forEach(e=>e.progress={});
            saveExercises(); renderExercises();
        }
    };

    function renderExercises(){
        // console.log("Rendering exercises. Current exercises array:", exercises); // Removed debug log
        document.getElementById('view-headline').textContent = isWeekly ? 'Weekly Planner' : 'Exercise Overview';
        const c=document.getElementById('tracker-content');
        c.innerHTML='';
        if (exercises.length === 0) {
            c.innerHTML = `<p style="text-align:center; color:#777; margin-top:30px;">No exercises for "${currentProfile}". Click "Add New Exercise".</p>`;
            updateProgress(); return;
        }
        // Ensure collapsedCategories is loaded/initialized before rendering
        if (typeof collapsedCategories !== 'object' || collapsedCategories === null) {
             // This case should ideally not happen if load logic is correct, but as fallback
             console.warn("collapsedCategories was not loaded correctly, initializing empty.");
             collapsedCategories = {}; // Default to empty object if not loaded
        }

        if(isWeekly) renderWeekly(c);
        else renderByCategory(c);
        updateProgress();
    }

    function renderByCategory(cont){
        const groupedExercises = {};
        const categoriesInOrder = allCategories(); // Use the categoryOrder

        // Initialize groups based on the current order
        categoriesInOrder.forEach(cat => groupedExercises[cat] = []);
        // Add a group for uncategorized exercises
        const uncategorizedName = "Uncategorized";
         groupedExercises[uncategorizedName] = [];


        exercises.forEach((ex, idx) => {
            // Find the canonical category name (case-insensitive match) in the *current* categoryOrder
            const canonicalCat = categoriesInOrder.find(c => c.toLowerCase() === (ex.category || "").toLowerCase());

            if (canonicalCat) {
                 // Add exercise to the correctly cased canonical category group
                 if (!groupedExercises[canonicalCat]) groupedExercises[canonicalCat] = []; // Should exist, but defensive
                 groupedExercises[canonicalCat].push({ e: ex, idx });
            } else {
                // Handle exercises with a category that no longer exists in categoryOrder
                 groupedExercises[uncategorizedName].push({ e: ex, idx });
            }
        });

        // Render categories in the specified order
        categoriesInOrder.forEach(cat=>{
            const items = groupedExercises[cat];
            if(!items || items.length === 0) return; // Skip if no exercises in this category

            const h=document.createElement('div');
            h.className='section-header';
            // Use category name for collapsedCategories key
            h.onclick=()=>{
                // Ensure collapsedCategories is an object before toggling
                if (typeof collapsedCategories !== 'object' || collapsedCategories === null) collapsedCategories = {};
                collapsedCategories[cat]=!collapsedCategories[cat];
                // Save to profile-specific key
                localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                renderExercises(); // Rerender to show/hide content
            };
            // --- MODIFIED: Use textContent for category name, create span separately ---
            const h2 = document.createElement('h2');
            h2.textContent = cat; // Use textContent - SAFE
            const span = document.createElement('span');
            // Check collapsed state from the loaded/saved object
            span.textContent = collapsedCategories[cat]?'+':'-'; // Use textContent - SAFE
            h.appendChild(h2);
            h.appendChild(span);
            // --- END MODIFIED ---

            cont.appendChild(h);
            // Check collapsed state from the loaded/saved object before rendering content
            if(!collapsedCategories[cat]){
                const d=document.createElement('div');
                d.className='section-content';
                items.forEach(({e, idx}) => d.appendChild(renderExerciseRow(e, idx)));
                cont.appendChild(d);
            }
        });

         // Always render Uncategorized at the end if it has exercises
        if (groupedExercises[uncategorizedName].length > 0) {
             const items = groupedExercises[uncategorizedName];
             const h=document.createElement('div');
            h.className='section-header';
            // Use "Uncategorized" as the key for collapsed state
            h.onclick=()=>{
                 // Ensure collapsedCategories is an object before toggling
                 if (typeof collapsedCategories !== 'object' || collapsedCategories === null) collapsedCategories = {};
                collapsedCategories[uncategorizedName]=!collapsedCategories[uncategorizedName];
                // Save to profile-specific key
                localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                renderExercises(); // Re-render to show/hide content
            };
            // --- MODIFIED: Use textContent for category name, create span separately ---
            const h2 = document.createElement('h2');
            h2.textContent = uncategorizedName; // Use textContent - SAFE
            const span = document.createElement('span');
            // Check collapsed state from the loaded/saved object
            span.textContent = collapsedCategories[uncategorizedName]?'+':'-'; // Use textContent - SAFE
            h.appendChild(h2);
            h.appendChild(span);
            // --- END MODIFIED ---

            cont.appendChild(h);
            // Check collapsed state from the loaded/saved object before rendering content
            if(!collapsedCategories[uncategorizedName]){
                const d=document.createElement('div');
                d.className='section-content';
                items.forEach(({e,idx})=>d.appendChild(renderExerciseRow(e, idx)));
                cont.appendChild(d);
            }
        }
    }

    function renderWeekly(cont){
        const byDay={};
        WEEKDAYS.forEach(d=>byDay[d]=[]);
        exercises.forEach((e,idx)=>{
            if (e.schedule) {
                Object.entries(e.schedule).forEach(([dayIndex,count])=>{
                    const dayIndexInt = parseInt(dayIndex);
                    if(!isNaN(dayIndexInt) && WEEKDAYS[dayIndexInt] && count > 0) {
                       byDay[WEEKDAYS[dayIndexInt]].push({e, idx, count});
                    }
                });
            }
        });
        WEEKDAYS.forEach(day=>{
            const dayItems = byDay[day];
            if(!dayItems.length)return;
            const h=document.createElement('div');
            h.className='section-header';
            // Use day name for collapsedCategories key
            h.onclick=()=>{
                 // Ensure collapsedCategories is an object before toggling
                 if (typeof collapsedCategories !== 'object' || collapsedCategories === null) collapsedCategories = {};
                collapsedCategories[day]=!collapsedCategories[day];
                // Save to profile-specific key
                localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                renderExercises(); // Rerender to show/hide content
            };
            // --- MODIFIED: Use textContent for day name, create span separately ---
            const h2 = document.createElement('h2');
            h2.textContent = day; // Use textContent - SAFE (day names are static)
            const span = document.createElement('span');
            // Check collapsed state from the loaded/saved object
            span.textContent = collapsedCategories[day]?'+':'-'; // Use textContent - SAFE
            h.appendChild(h2);
            h.appendChild(span);
            // --- END MODIFIED ---

            cont.appendChild(h);
            // Check collapsed state from the loaded/saved object before rendering content
            if(!collapsedCategories[day]){
                const d=document.createElement('div');
                d.className='section-content';
                dayItems.forEach(({e,idx,count,dayKey})=>d.appendChild(renderExerciseRow(e,idx,count,day)));
                cont.appendChild(d);
            }
        });
    }

    function renderExerciseRow(exercise, index, repsCountForDay, dayKey){
        const row=document.createElement('div'); row.className='exercise-row';
        const headerRow=document.createElement('div'); headerRow.className='header-row'; // flex container

        const nameDiv=document.createElement('div'); nameDiv.className='name'; nameDiv.textContent=exercise.name;

        // Controls (edit button) - remains a separate flex item, auto margin pushes it right
        const controlsDiv = document.createElement('div');
        const editBtn=document.createElement('button');
        editBtn.className='edit-button'; editBtn.textContent='edit';
        editBtn.onclick=(e)=>{ e.stopPropagation(); openModal(index); };
        controlsDiv.appendChild(editBtn);

        // Append name and controls to the header row
        headerRow.appendChild(nameDiv);
        headerRow.appendChild(controlsDiv); // Place controls last in the flex container


        row.appendChild(headerRow); // Add header row to main row


        // Display Weight, Reps, or Duration based on properties, in one line
        const detailsParts = [];

        // Add Weight if available and > 0
        if (exercise.weight !== undefined && exercise.weight !== null && typeof exercise.weight === 'number' && exercise.weight > 0) {
            const formattedWeight = Number.isInteger(exercise.weight) ? exercise.weight : exercise.weight.toFixed(1);
            detailsParts.push(`${formattedWeight} kg`);
        }

        // Add Reps if available and > 0
        if (exercise.reps !== undefined && exercise.reps !== null && typeof exercise.reps === 'number' && exercise.reps > 0) {
            detailsParts.push(`${exercise.reps} reps`);
        }

        // Add Duration if available and non-empty
        if (exercise.duration !== undefined && exercise.duration !== null && typeof exercise.duration === 'string' && exercise.duration.trim() !== '') {
            detailsParts.push(exercise.duration.trim()); // Trim whitespace
        }

        // Only create and append the details div if there's something to display
        if (detailsParts.length > 0) {
            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'reps-duration'; // Reuse the reps-duration class styling
            detailsDiv.textContent = detailsParts.join(' / '); // Join parts with " / "
            row.appendChild(detailsDiv);
        }


        const checkboxGroupOuter = document.createElement('div');

        if(isWeekly && dayKey != null && repsCountForDay != null){
            const checkboxGroup=document.createElement('div'); checkboxGroup.className='checkbox-group';
            for(let k=0;k<repsCountForDay;k++){
                const cb=document.createElement('input'); cb.type='checkbox';
                const progressKey=`${dayKey}-${index}-${k}`;
                cb.checked=!!(exercise.progress&&exercise.progress[progressKey]);
                cb.onchange=()=>{
                    exercise.progress=exercise.progress||{};
                    exercise.progress[progressKey]=cb.checked;
                    saveExercises(); updateProgress();
                };
                checkboxGroup.appendChild(cb);
            }
            if (checkboxGroup.hasChildNodes()) checkboxGroupOuter.appendChild(checkboxGroup);
        } else if (!isWeekly) {
            let totalScheduledSets = 0;
            if(exercise.schedule) Object.values(exercise.schedule).forEach(count => totalScheduledSets += count);

            if (totalScheduledSets > 0) {
                Object.entries(exercise.schedule).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).forEach(([dayIndexStr,count])=>{
                    const dayIndex = parseInt(dayIndexStr);
                    if (count > 0 && dayIndex >= 0 && dayIndex < WEEKDAYS.length) {
                        const weekdayRow = document.createElement('div'); weekdayRow.className = 'weekday-row';
                        const weekdayLabel = document.createElement('span');
                        weekdayLabel.className = 'weekday-label'; weekdayLabel.textContent = WEEKDAYS[dayIndex];
                        const singleDayCheckboxGroup = document.createElement('div'); singleDayCheckboxGroup.className = 'checkbox-group';
                        for(let k=0;k<count;k++){
                            const cb=document.createElement('input'); cb.type='checkbox';
                            const currentDayKey = WEEKDAYS[dayIndex];
                            const progressKey=`${currentDayKey}-${index}-${k}`;
                            cb.checked=!!(exercise.progress&&exercise.progress[progressKey]);
                            cb.onchange=()=>{
                                exercise.progress=exercise.progress||{};
                                exercise.progress[progressKey]=cb.checked;
                                saveExercises(); updateProgress();
                            };
                            singleDayCheckboxGroup.appendChild(cb);
                        }
                        weekdayRow.appendChild(weekdayLabel); weekdayRow.appendChild(singleDayCheckboxGroup);
                        checkboxGroupOuter.appendChild(weekdayRow);
                    }
                });
            } else {
                 const noScheduleInfo = document.createElement('div');
                 noScheduleInfo.className = 'reps-duration'; noScheduleInfo.textContent = 'Not scheduled.';
                 noScheduleInfo.style.fontStyle = 'italic'; checkboxGroupOuter.appendChild(noScheduleInfo);
            }
        }
        if (checkboxGroupOuter.hasChildNodes()) row.appendChild(checkboxGroupOuter);
        return row;
    }

    function updateProgress(){
        let totalSets=0, completedSets=0;
        exercises.forEach((ex, exerciseIdx) => {
            if (ex.schedule) {
                Object.entries(ex.schedule).forEach(([dayIndexStr, setCount]) => {
                    const dayIndex = parseInt(dayIndexStr);
                    if (!isNaN(dayIndex) && dayIndex >= 0 && dayIndex < WEEKDAYS.length) {
                        totalSets += setCount;
                        const dayKey = WEEKDAYS[dayIndex];
                        if (dayKey) {
                            for (let k = 0; k < setCount; k++) {
                                const progressKey = `${dayKey}-${exerciseIdx}-${k}`;
                                if (ex.progress && ex.progress[progressKey]) completedSets++;
                            }
                        }
                    }
                });
            }
        });
        const percentage = totalSets > 0 ? Math.round((completedSets / totalSets) * 100) : 0;
        document.getElementById('progress-fill').style.width = percentage + '%';
        document.getElementById('progress-label').textContent = percentage + '%';
    }

    function ensureScheduleFormat(ex) {
        if (!ex.schedule || typeof ex.schedule !== 'object') {
            ex.schedule = {};
        }
        const newSchedule = {};
        for (const dayIdxStr in ex.schedule) {
            const dayIdx = parseInt(dayIdxStr);
            const count = parseInt(ex.schedule[dayIdxStr]);
            if (!isNaN(dayIdx) && dayIdx >= 0 && dayIdx < WEEKDAYS.length && !isNaN(count) && count > 0) {
                newSchedule[dayIdx] = count;
            }
        }
        ex.schedule = newSchedule;
        if (!ex.progress || typeof ex.progress !== 'object') ex.progress = {};

         // --- Weight Migration/Adaptation START ---
         // Ensure weight is a number or null
         if (ex.weight !== undefined && ex.weight !== null) {
             const val = parseFloat(ex.weight);
             ex.weight = !isNaN(val) && val >= 0 ? val : null;
         } else {
              ex.weight = null; // Ensure property exists
         }
         // --- Weight Migration/Adaptation END ---


        // --- Reps/Duration Migration/Adaptation START ---
        // If old 'reps' string exists and new 'reps'/'duration' don't, try to parse
        if (ex.reps !== undefined && typeof ex.reps === 'string' && ex.duration === undefined) {
             const oldRepsStr = ex.reps.trim();
             const numValue = parseInt(oldRepsStr);
             // Simple check: if parsing as int results in the original string (no extra text), treat as number reps
             if (!isNaN(numValue) && numValue >= 0 && String(numValue) === oldRepsStr) {
                 ex.reps = numValue;
                 ex.duration = null;
             } else if (oldRepsStr !== '') {
                  // Otherwise, treat as duration text
                 ex.duration = oldRepsStr;
                 ex.reps = null;
             } else {
                 // Empty string
                 ex.reps = null;
                 ex.duration = null;
             }
         } else if (ex.reps === undefined && ex.duration === undefined) {
             // If neither property exists (very old data?), default to nulls
             ex.reps = null;
             ex.duration = null;
         }
         // Ensure reps is number or null, and duration is string or null if they exist
         if (ex.reps !== undefined && ex.reps !== null && typeof ex.reps !== 'number') {
              const val = parseInt(ex.reps);
              ex.reps = !isNaN(val) && val >= 0 ? val : null;
              // If old reps was text and duration didn't exist, ensure that text goes to duration
              if (ex.reps === null && ex.duration === undefined && typeof Object.getOwnPropertyDescriptor(ex, 'reps').value === 'string') { // Check the original property type before parsing
                   ex.duration = Object.getOwnPropertyDescriptor(ex, 'reps').value; // Put old reps string in duration if it couldn't be parsed as number and duration didn't exist
              } else if (ex.duration === undefined) {
                   ex.duration = null; // Ensure duration is null if not set
              }
         } else if (ex.reps === undefined) { // Ensure reps is null if it didn't exist at all
             ex.reps = null;
         }

         if (ex.duration !== undefined && ex.duration !== null && typeof ex.duration !== 'string') {
             ex.duration = String(ex.duration); // Ensure it's a string
         } else if (ex.duration === undefined) { // Ensure duration is null if it didn't exist at all
             ex.duration = null;
         }


        // --- Reps/Duration Migration/Adaptation END ---


        // Clean up old/unused properties if they exist
        delete ex.weekdays;
        if (ex.days && Array.isArray(ex.days)) { // Migrate old days array format to schedule object if found
             if (Object.keys(ex.schedule).length === 0) { // Only migrate if schedule is empty
                ex.days.forEach(dayIdx => {
                    if (!isNaN(dayIdx) && dayIdx >= 0 && dayIdx < WEEKDAYS.length) {
                        ex.schedule[dayIdx] = 1; // Assume 1 set if migrating from old format
                    }
                });
             }
             delete ex.days;
        }
         // Clean up old string reps property if it's not the one we kept as duration
         if (typeof Object.getOwnPropertyDescriptor(ex, 'reps') !== 'undefined' && typeof Object.getOwnPropertyDescriptor(ex, 'reps').value === 'string' && ex.duration !== Object.getOwnPropertyDescriptor(ex, 'reps').value) {
              delete ex.reps;
         } else if (typeof ex.reps === 'string' && ex.duration !== ex.reps) {
             // Fallback check if getOwnPropertyDescriptor is tricky
             delete ex.reps;
         }


        return ex;
    }

    document.addEventListener('click', function(event) {
        const menu = document.getElementById('dropdown-menu');
        const icon = document.querySelector('.menu-icon');
        if (menu && icon && menu.classList.contains('show') &&
            !icon.contains(event.target) && !menu.contains(event.target)) {
            menu.classList.remove('show');
        }
    });

    let profiles = {};
    let currentProfile = "Default";

    function loadProfiles() {
        const storedProfiles = localStorage.getItem("profiles");
        if (storedProfiles) {
            try { profiles = JSON.parse(storedProfiles); } catch(e) { profiles = {"Default": []}; console.error("Error parsing profiles from localStorage", e); }
        } else {
            profiles = { "Default": [] };
        }
        currentProfile = localStorage.getItem("currentProfile") || Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default";
        if (!profiles[currentProfile]) {
            currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default";
            if (!profiles[currentProfile] && Object.keys(profiles).length === 0) { // If profiles is truly empty
                 profiles["Default"] = [];
                 currentProfile = "Default";
            }
            localStorage.setItem("currentProfile", currentProfile);
        }
         if (Object.keys(profiles).length === 0) { // Absolute fallback
            profiles["Default"] = [];
            currentProfile = "Default";
            localStorage.setItem("currentProfile", currentProfile);
            localStorage.setItem("profiles", JSON.stringify(profiles));
        }
    }

    function loadProfileOptions() {
        const sel = document.getElementById("profile-select");
        sel.innerHTML = '';
        const sortedProfileNames = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()));


        if (sortedProfileNames.length === 0) { // Should be caught by loadProfiles
            profiles["Default"] = []; currentProfile = "Default";
            localStorage.setItem("currentProfile", currentProfile); localStorage.setItem("profiles", JSON.stringify(profiles));
            sortedProfileNames.push("Default");
        }

        sortedProfileNames.forEach(name => {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            sel.appendChild(option);
        });
        sel.value = currentProfile;
        document.getElementById('profile-container').style.display = 'flex'; // Always show if it exists
    }

    function switchProfile() {
        const selectedProfileName = document.getElementById("profile-select").value;
        if (selectedProfileName && profiles.hasOwnProperty(selectedProfileName)) {
            currentProfile = selectedProfileName;
            localStorage.setItem("currentProfile", currentProfile);
            exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);

            // Load or initialize collapsed state for the new profile
             const collapsedKey = 'collapsedCategories_' + currentProfile;
             const storedCollapsed = localStorage.getItem(collapsedKey);

             if (storedCollapsed === null) {
                 // First time loading this profile - collapse everything
                 collapsedCategories = {};
                 // Need categories to collapse, so ensure categoryOrder is loaded first
                 if (categoryOrder.length === 0) loadCategoryOrder(); // Defensive check
                 allCategories().forEach(cat => collapsedCategories[cat] = true); // Collapse categories
                 WEEKDAYS.forEach(day => collapsedCategories[day] = true); // Collapse weekdays
                  localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save the newly collapsed state
                 console.log(`Profile "${currentProfile}" loaded for the first time, collapsing sections.`);

             } else {
                // Profile has been loaded before, load saved collapsed state
                try {
                     collapsedCategories = JSON.parse(storedCollapsed);
                     console.log(`Profile "${currentProfile}" loaded, restored collapsed state.`);
                } catch (e) {
                    console.error("Error parsing collapsed state for profile", currentProfile, e);
                    collapsedCategories = {}; // Fallback to empty (uncollapsed) on parse error
                    localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save empty state
                }
             }


            renderExercises();
            populateExerciseCategoryDropdown();
        } else if (Object.keys(profiles).length > 0) { // Fallback to first profile (alphabetical)
            currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0];
            localStorage.setItem("currentProfile", currentProfile);
            document.getElementById("profile-select").value = currentProfile;
            exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);

             // Load or initialize collapsed state for the fallback profile
            const collapsedKey = 'collapsedCategories_' + currentProfile;
            const storedCollapsed = localStorage.getItem(collapsedKey);

             if (storedCollapsed === null) {
                 // First time loading this profile - collapse everything
                 collapsedCategories = {};
                 // Need categories to collapse, so ensure categoryOrder is loaded first
                 if (categoryOrder.length === 0) loadCategoryOrder(); // Defensive check
                 allCategories().forEach(cat => collapsedCategories[cat] = true); // Collapse categories
                 WEEKDAYS.forEach(day => collapsedCategories[day] = true); // Collapse weekdays
                 localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save the newly collapsed state
                 console.log(`Fallback profile "${currentProfile}" loaded for the first time, collapsing sections.`);

             } else {
                // Profile has been loaded before, load saved collapsed state
                try {
                     collapsedCategories = JSON.parse(storedCollapsed);
                     console.log(`Fallback profile "${currentProfile}" loaded, restored collapsed state.`);
                } catch (e) {
                    console.error("Error parsing collapsed state for fallback profile", currentProfile, e);
                    collapsedCategories = {}; // Fallback to empty (uncollapsed) on parse error
                    localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save empty state
                }
             }

            renderExercises(); populateExerciseCategoryDropdown();
        } else { // Should not be reached if loadProfiles ensures Default exists
            console.error("No profiles available to switch to.");
        }
    }

     // Save exercises AND collapsed state specific to the current profile
    function saveExercises() {
        if (!profiles[currentProfile]) profiles[currentProfile] = [];
        profiles[currentProfile] = exercises.map(ex => {
             const savedEx = {
                name: ex.name,
                category: ex.category,
                schedule: ex.schedule,
                progress: ex.progress
             };
             // Save weight only if it's a non-null number >= 0
             if (ex.weight !== undefined && ex.weight !== null && typeof ex.weight === 'number' && ex.weight >= 0) {
                 savedEx.weight = ex.weight;
             }
             // Save reps only if it's a non-null number >= 0
             if (ex.reps !== undefined && ex.reps !== null && typeof ex.reps === 'number' && ex.reps >= 0) {
                 savedEx.reps = ex.reps;
             }
              // Save duration only if it's a non-null, non-empty string
              if (ex.duration !== undefined && ex.duration !== null && typeof ex.duration === 'string' && ex.duration.trim() !== '') {
                 savedEx.duration = ex.duration;
             }
             return savedEx;
        });
        localStorage.setItem("profiles", JSON.stringify(profiles));
         // Save collapsed state specific to the current profile
         localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
         // console.log("Profiles object saved:", JSON.parse(localStorage.getItem("profiles"))); // Debug log removed
    }


    function openProfileModal() {
        document.getElementById('dropdown-menu').classList.remove('show');
        document.getElementById('profile-modal-overlay').classList.add('active');
        document.getElementById('profile-modal').classList.add('active');
        populateProfileModal();
    }
    function closeProfileModal() {
        document.getElementById('profile-modal-overlay').classList.remove('active');
        document.getElementById('profile-modal').classList.remove('active');
    }

    function populateProfileModal() {
        const list = document.getElementById('profile-list');
        list.innerHTML = '';
        const sortedProfileNames = Object.keys(profiles).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

        sortedProfileNames.forEach(name => {
            const originalName = name;

            const item = document.createElement('div');
            item.className = 'modal-item';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalName;
            nameSpan.style.flexGrow = "1";

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'modal-input list-rename-input';
            nameInput.value = originalName;
            nameInput.style.display = 'none';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.className = 'modal-button';

            const saveRenameBtn = document.createElement('button');
            saveRenameBtn.textContent = 'Save';
            saveRenameBtn.className = 'modal-button save';
            saveRenameBtn.style.display = 'none';

            const cancelRenameBtn = document.createElement('button');
            cancelRenameBtn.textContent = 'Cancel';
            cancelRenameBtn.className = 'modal-button cancel';
            cancelRenameBtn.style.display = 'none';

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'x';
            deleteBtn.className = 'modal-button delete';
            deleteBtn.disabled = (Object.keys(profiles).length <= 1); // Disable delete if only one profile exists

            const controlsDiv = document.createElement('div'); // To group buttons
            controlsDiv.style.display = 'flex'; controlsDiv.style.alignItems = 'center'; controlsDiv.style.gap = '8px';
            controlsDiv.appendChild(renameBtn); controlsDiv.appendChild(saveRenameBtn);
            controlsDiv.appendChild(cancelRenameBtn); controlsDiv.appendChild(deleteBtn);

            item.appendChild(nameSpan); item.appendChild(nameInput); item.appendChild(controlsDiv);
            list.appendChild(item);

            renameBtn.onclick = () => {
                nameSpan.style.display = 'none';
                nameInput.style.display = 'block'; nameInput.style.flexGrow = "1"; // Set flex-grow here too
                nameInput.value = nameSpan.textContent; nameInput.focus();
                renameBtn.style.display = 'none';
                saveRenameBtn.style.display = 'inline-block';
                cancelRenameBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            };
            cancelRenameBtn.onclick = () => {
                nameSpan.style.display = 'block';
                nameInput.style.display = 'none'; nameInput.style.flexGrow = "0"; // Reset flex-grow
                renameBtn.style.display = 'inline-block';
                saveRenameBtn.style.display = 'none';
                cancelRenameBtn.style.display = 'none';
                deleteBtn.style.display = 'inline-block';
            };
            saveRenameBtn.onclick = () => {
                const newNameTrimmed = nameInput.value.trim();
                if (!newNameTrimmed) {
                    alert("Profile name cannot be empty."); nameInput.focus(); return;
                }
                if (newNameTrimmed.toLowerCase() === originalName.toLowerCase() && newNameTrimmed === originalName) {
                    cancelRenameBtn.onclick(); return;
                }
                for (const existingProfileName in profiles) {
                    if (existingProfileName.toLowerCase() === newNameTrimmed.toLowerCase() && existingProfileName.toLowerCase() !== originalName.toLowerCase()) {
                        alert(`Profile name "${newNameTrimmed}" already exists or conflicts with another profile.`);
                        nameInput.focus(); return;
                    }
                }
                 // Case-insensitive rename check passed, perform the rename
                const profileData = profiles[originalName];
                delete profiles[originalName];
                profiles[newNameTrimmed] = profileData;

                 // Also rename the collapsed state key in localStorage
                 const oldCollapsedKey = 'collapsedCategories_' + originalName;
                 const newCollapsedKey = 'collapsedCategories_' + newNameTrimmed;
                 const collapsedState = localStorage.getItem(oldCollapsedKey);
                 if (collapsedState !== null) {
                      localStorage.setItem(newCollapsedKey, collapsedState);
                      localStorage.removeItem(oldCollapsedKey);
                 }


                if (currentProfile === originalName) {
                    currentProfile = newNameTrimmed;
                    localStorage.setItem("currentProfile", currentProfile);
                     // Update the current collapsed state object reference if this was the active profile
                    try {
                        collapsedCategories = JSON.parse(localStorage.getItem(newCollapsedKey)) || {};
                    } catch (e) {
                        console.error("Error loading renamed collapsed state for profile", newNameTrimmed, e);
                        collapsedCategories = {};
                    }

                }
                localStorage.setItem("profiles", JSON.stringify(profiles));
                alert(`Profile "${originalName}" renamed to "${newNameTrimmed}".`);
                populateProfileModal(); loadProfileOptions();
                if (document.getElementById("profile-select").value !== currentProfile) {
                    document.getElementById("profile-select").value = currentProfile;
                }
                if (currentProfile === newNameTrimmed && exercises === profileData) { // if current profile data was affected
                    renderExercises();
                }
            };
            deleteBtn.onclick = function() {
                if (deleteBtn.disabled) { alert("Cannot delete the last profile."); return;}
                if (confirm(`Delete profile "${originalName}"? This cannot be undone.`)) {
                    const nameToDelete = originalName;
                    delete profiles[nameToDelete];

                     // Also remove the collapsed state key from localStorage
                     const collapsedKeyToDelete = 'collapsedCategories_' + nameToDelete;
                     localStorage.removeItem(collapsedKeyToDelete);


                    let profileSwitchedOrRefreshed = false;
                    if (currentProfile === nameToDelete) {
                        currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default"; // Switch to the first alphabetical
                        localStorage.setItem('currentProfile', currentProfile);
                         // Load collapsed state for the new current profile
                         try {
                             collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories_' + currentProfile)) || {};
                         } catch (e) {
                            console.error("Error loading collapsed state for new current profile", currentProfile, e);
                            collapsedCategories = {};
                         }

                        profileSwitchedOrRefreshed = true;
                    }
                    if(Object.keys(profiles).length === 0) { // Should technically not happen with the check above, but as a fallback
                        profiles["Default"] = []; currentProfile = "Default";
                        localStorage.setItem("currentProfile", currentProfile);
                         // Load/initialize collapsed state for the default profile
                         try {
                             collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories_Default')) || {};
                         } catch (e) {
                             console.error("Error loading collapsed state for default profile", currentProfile, e);
                             collapsedCategories = {};
                         }
                        profileSwitchedOrRefreshed = true;
                    }
                    localStorage.setItem("profiles", JSON.stringify(profiles));
                    populateProfileModal(); loadProfileOptions();
                    if (profileSwitchedOrRefreshed) {
                        exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);
                        renderExercises();
                    }
                }
            };
        });
        document.getElementById('new-profile-name-input').value = '';
    };
    document.getElementById('profile-modal-overlay').onclick = closeProfileModal;

    document.addEventListener('DOMContentLoaded', () => {
        loadProfiles(); loadCategoryOrder(); // Ensure categories are loaded before initializing collapsed state
        loadProfileOptions(); // Ensure profile select is populated


        exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat); // Ensure exercises are in correct format on load
        isWeekly = localStorage.getItem('isWeeklyView') === 'true'; // Load view mode preference

        // Load or initialize collapsed state for the initial profile
        const collapsedKey = 'collapsedCategories_' + currentProfile;
        const storedCollapsed = localStorage.getItem(collapsedKey);

        if (storedCollapsed === null || storedCollapsed === undefined) { // Check for undefined too
             // First time loading this profile - collapse everything
             collapsedCategories = {};
             // Need categories to collapse, so ensure categoryOrder is loaded first
             if (categoryOrder.length === 0) loadCategoryOrder(); // Defensive check
             allCategories().forEach(cat => collapsedCategories[cat] = true); // Collapse categories
             WEEKDAYS.forEach(day => collapsedCategories[day] = true); // Collapse weekdays
             localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save the newly collapsed state
              console.log(`Initial profile "${currentProfile}" loaded for the first time or key missing, collapsing sections.`);

        } else {
            // Profile has been loaded before, load saved collapsed state
            try {
                 collapsedCategories = JSON.parse(storedCollapsed);
                 console.log(`Initial profile "${currentProfile}" loaded, restored collapsed state.`);
            } catch (e) {
                console.error("Error parsing collapsed state on DOMContentLoaded for profile", currentProfile, e);
                collapsedCategories = {}; // Fallback to empty (uncollapsed) on parse error
                localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save empty state
            }
        }

        renderExercises(); // Render using the loaded category order and collapsed state
        populateExerciseCategoryDropdown(); // Populate dropdown using the loaded order

         // Migration check for old collapsedCategories storage (non-profile specific) - run once on load if needed
         const oldCollapsedState = localStorage.getItem('collapsedCategories');
         if (oldCollapsedState !== null && oldCollapsedState !== undefined) {
             const newCollapsedKey = 'collapsedCategories_' + currentProfile;
             const newCollapsedKeyExists = localStorage.getItem(newCollapsedKey) !== null;

             // Only migrate if the old key exists and the NEW profile-specific key does NOT exist
             if (!newCollapsedKeyExists) {
                 console.log(`Migrating old non-profile collapsedCategories state for profile "${currentProfile}"...`);
                 try {
                      const stateToMigrate = JSON.parse(oldCollapsedState);
                      if (typeof stateToMigrate === 'object' && stateToMigrate !== null) {
                         localStorage.setItem(newCollapsedKey, JSON.stringify(stateToMigrate));
                         console.log("Migration successful. Old key 'collapsedCategories' is now redundant.");
                         // Optionally remove the old key after successful migration
                         // localStorage.removeItem('collapsedCategories'); // Consider removing this after a few versions
                      } else {
                         console.error("Old collapsedCategories data is not a valid object, skipping migration.");
                         // Initialize the new key as empty if migration failed
                         localStorage.setItem(newCollapsedKey, JSON.stringify({}));
                      }
                 } catch(e) {
                      console.error("Error parsing old collapsedCategories for migration:", e);
                      // Initialize the new key as empty if migration failed
                      localStorage.setItem(newCollapsedKey, JSON.stringify({}));
                 }
                 // After potential migration, reload collapsedCategories from the correct key
                 try {
                     collapsedCategories = JSON.parse(localStorage.getItem(newCollapsedKey)) || {};
                 } catch (e) {
                     console.error("Error reloading collapsed state after migration:", e);
                     collapsedCategories = {};
                 }
                  renderExercises(); // Re-render to reflect potentially migrated collapsed state
             }
         }
    });

  </script>
</body>
</html>
