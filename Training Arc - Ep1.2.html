<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Training Arc: GtG Loop Tracker</title>
  <style>
  /* Reset and base */
  *, *::before, *::after { box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 650px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f8f8f8;
    color: #333;
    overflow-x: hidden;
  }
  input[type="checkbox"] {
    accent-color: #00BFFF;
    width: 18px;
    height: 18px;
    cursor: pointer;
  }

  /* Header and menu */
  .header-container {
    display: grid;
    grid-template-columns: 30px 1fr 30px; /* Left-spacer | Logo | Menu-container */
    align-items: center;
    width: 100%;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
    margin-bottom: 25px;
    height: 45px; /* Explicit height for better vertical centering of menu */
  }
  .header-container > div:first-child { /* Left spacer */
    grid-column: 1;
  }
  .logo-container {
    grid-column: 2;
    text-align: center;
    font-weight: 600;
    font-size: 1.5rem;
    color: #222;
  }
  .menu-container {
    grid-column: 3;
    justify-self: end;
    position: relative; /* For dropdown menu */
    display: flex;
    align-items: center;
    height: 100%; /* Ensure it fills grid cell height for menu centering */
  }
  .menu-icon { /* Kebab menu icon itself */
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 20px; /* Intrinsic size */
    width: 24px;  /* Intrinsic size */
    padding: 2px;
    font-weight: normal; /* Ensure not bold */
  }
  .menu-icon .dot {
    width: 5px;
    height: 5px;
    background-color: #555;
    border-radius: 50%;
  }

  /* Unified menu & modal item style */
  #dropdown-menu, .modal {
    background-color: #ffffff;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  #dropdown-menu {
    position: absolute;
    top: 30px; /* Adjusted based on menu icon position */
    right: 0;
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
    transform-origin: top right;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    z-index: 1000;
    pointer-events: none;
    min-width: 200px;
  }
  #dropdown-menu.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
  }
  .dropdown-item, .modal-item { /* Removed .cat-item */
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    font-size: 0.95rem;
    user-select: none;
    background-color: #fff;
    color: #333;
    transition: background-color 0.15s ease;
  }
   .modal-item { /* Specific for profile/category list items */
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .preset-item { /* This class is no longer used for list items in the modal */
    padding: 5px 10px;
    cursor: pointer;
    font-size: 0.9rem;
    user-select: none;
    color: #333;
    transition: background-color 0.15s ease;
    border-radius: 4px;
    border: 1px solid #d1d5db;
    background-color: #f9f9f9;
  }
  .preset-item:disabled {
    opacity: 0.6;
    cursor: default;
    background-color: #e9ecef;
  }
  .dropdown-item:last-child, .modal-item:last-child { /* Removed .cat-item */
    border-bottom: none;
  }
  .dropdown-item:hover, .modal-item:hover, .preset-item:hover:not(:disabled) { /* Removed .cat-item */
    background-color: #f0f0f0;
  }

  /* Progress & Headline */
  #progress-container {
    margin-bottom: 20px;
  }
  #progress-bar {
    height: 12px;
    width: 100%;
    background-color: #e9ecef;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.075);
  }
  #progress-fill {
    height: 100%;
    width: 0;
    background: linear-gradient(to right, cyan, magenta, yellow);
    transition: width 0.4s ease-in-out;
    border-radius: 6px;
  }
  #progress-label {
    text-align: right;
    font-size: 0.9rem;
    margin-top: 6px;
    color: #555;
  }
  .view-headline {
    font-size: 1.3rem;
    margin: 15px 0 20px; /* Original spacing from content */
    text-align: center;
    color: #333;
    font-weight: 500;
  }

  /* Profile Selector Styling */
  #profile-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 5px 0 15px;
  }
  #profile-select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: transparent;
    border: none;
    padding: 5px 8px;
    font-size: 1.1rem;
    font-weight: normal;
    cursor: pointer;
    outline: none;
    margin: 0;
    text-align: center;
    text-align-last: center;
    text-decoration: underline;
    color: #555;
  }
  #profile-select::-ms-expand {
    display: none;
  }


  /* Sections and rows */
  .section-header {
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #e9ecef;
    padding: 10px 15px;
    border-radius: 6px;
    margin-top: 15px;
    transition: background-color 0.2s ease;
  }
  .section-header:hover {
    background-color: #dce2e8;
  }
  .section-header h2 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 500;
    color: #333;
  }
  .section-header span { /* For + / - icons */
    font-size: 0.85rem;
    font-weight: bold;
    color: #777;
    display: inline-block;
    min-width: 1.5em;
    text-align: center;
    line-height: 1;
  }
  .section-content {
    margin-top: 10px;
    padding-left: 5px;
  }
  .exercise-row {
    display: flex;
    flex-direction: column;
    background-color: #fff;
    padding: 12px 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.07);
    border: 1px solid #e7e7e7;
    transition: box-shadow 0.2s ease;
  }
  .exercise-row:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  .exercise-row .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }
  .exercise-row .name {
    font-size: 1.05rem;
    font-weight: 500;
    color: #222;
  }
  .reps-duration {
    color: #777;
    font-size: 0.9rem;
    margin-top: 4px;
    margin-bottom: 8px;
  }
  .weekday-row {
    display: flex;
    align-items: center;
    margin-top: 6px;
    padding: 4px 0;
  }
  .weekday-label {
    color: #444;
    font-size: 0.9rem;
    width: 70px;
    font-weight: 500;
  }
  .checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-left: 8px;
  }
  .checkbox-container {
    display: flex;
    align-items: center;
  }
  .edit-button {
    color: #777;
    font-size: 0.85rem;
    font-weight: 400;
    background-color: transparent;
    border: none;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s ease, color 0.2s ease;
  }
  .edit-button:hover {
    background-color: #e6f2ff;
    color: #007bff;
  }

  /* Buttons */
  .app-button {
    padding: 12px 18px;
    font-size: 1rem;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    width: 100%;
    margin-top: 15px;
    transition: opacity 0.2s ease, transform 0.1s ease;
    text-align: center;
  }
  .app-button:hover {
    opacity: 0.85;
  }
  .app-button:active {
    transform: translateY(1px);
  }

  .add-button {
    background-color: #00BFFF;
    color: #FFFFFF;
  }
  .reset-button {
    background-color: magenta;
    color: #fff;
  }

  /* Modal specifics */
  .modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background-color: rgba(0,0,0,0.5);
    z-index: 998; display: none;
  }
  .modal-overlay.active { display: block; }
  .modal {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    padding: 20px 25px;
    z-index: 999; width: 90%; max-width: 450px;
    max-height: 90vh; overflow-y: auto; display: none;
    opacity: 0; transition: opacity 0.25s ease-out, transform 0.25s ease-out;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
  }
  .modal.active {
    display: block; opacity: 1; transform: translate(-50%, -50%) scale(1);
  }
  .modal h3 {
    margin-top: 0; margin-bottom: 20px;
    font-size: 1.4rem; color: #333;
    text-align: center; font-weight: 500;
  }
  .modal-label {
    display: block; margin-bottom: 6px; font-size: 0.9rem;
    color: #444; font-weight: 500;
  }
  .modal-input, .modal-number, .modal-select {
    width: 100%; padding: 10px 12px; margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1rem; height: auto;
    background-color: #fff;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  /* Input field used for renaming in lists */
  .list-rename-input {
    margin-bottom: 0 !important; /* Override .modal-input margin */
    flex-grow: 1;
  }

  .modal-input:focus, .modal-number:focus, .modal-select:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
    outline: none;
  }
  #ex-cat { /* Select for exercise category */
    appearance: none;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3csvg%3e");
    background-repeat: no-repeat; background-position: right .75rem center; background-size: 16px 12px;
  }

  .modal-actions {
    display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;
  }
  .modal-button {
    padding: 10px 18px; font-size: 0.95rem; font-weight: 500;
    border: none; border-radius: 6px; cursor: pointer;
    transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
  }
   .modal-button:active { transform: translateY(1px); }
  .modal-button.save { background-color: #00BFFF; color: #fff; }
  .modal-button.cancel { background-color: #6c757d; color: #fff; }

  .modal-button.delete {
    background-color: magenta;
    color: #fff;
    padding: 8px 12px;
    font-size: 1.1rem;
    font-weight: bold;
    line-height: 1;
    min-width: auto;
    margin-right: auto; /* For main modal delete button like exercise delete */
  }
  /* Smaller buttons inside lists (profile/category rename/delete) */
  .modal-item .modal-button {
    padding: 6px 10px;
    font-size: 0.85rem;
  }
  .modal-item .modal-button.delete { /* 'x' delete button in lists */
     margin-right: 0;
     padding: 6px 10px;
     font-size: 1rem;
  }

  .modal-button.delete:hover, .modal-button.save:hover, .modal-button.cancel:hover {
    opacity: 0.85;
  }

  #add-profile-btn, #add-cat-btn { /* Specific Add buttons in modals */
    background-color: #00BFFF;
    color: #FFFFFF;
  }

  /* --- DRAG & DROP & CATEGORY MANAGEMENT START --- */
  #cat-list, #profile-list { /* Removed #preset-list */
    margin-top: 10px; margin-bottom: 20px;
  }

  #cat-list .modal-item {
      cursor: grab; /* Indicate draggable item */
      position: relative; /* Needed for drag-over effect */
      z-index: 1; /* Ensure items are above potential drag indicators */
  }

  #cat-list .modal-item.dragging {
      opacity: 0.5; /* Make the item being dragged semi-transparent */
  }

  #cat-list .modal-item.drag-over-before {
      border-top: 2px dashed #007bff; /* Visual cue for drop target */
  }

   #cat-list .modal-item.drag-over-after {
      border-bottom: 2px dashed #007bff; /* Visual cue for drop target */
  }
  /* --- DRAG & DROP & CATEGORY MANAGEMENT END --- */


  #schedule-inputs {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px; margin-top: 10px; margin-bottom: 15px;
  }
  #schedule-inputs .modal-label { margin-bottom: 4px; font-size: 0.85rem; }
  #schedule-inputs .modal-number { margin-bottom: 0; text-align: center; }

</style>
</head>
<body>
  <div class="header-container">
    <div></div> <div class="logo-container">Training Arc</div>
    <div class="menu-container">
      <div class="menu-icon" onclick="toggleMenu()">
        <div class="dot"></div><div class="dot"></div><div class="dot"></div>
      </div>
      <div id="dropdown-menu">
        <div class="dropdown-item" onclick="toggleViewMode()">Toggle View Mode</div>
        <div class="dropdown-item" onclick="openProfileModal()">Manage Profiles</div>
        <div class="dropdown-item" onclick="openCatModal()">Manage Categories</div>
        <div class="dropdown-item" onclick="exportExercises()">Export Exercises</div>
        <div class="dropdown-item" onclick="importExercises()">Import Exercises</div>
        <div class="dropdown-item" onclick="clearExercises()">Clear All Exercises</div>
        <div class="dropdown-item" onclick="showAbout()">About</div>
      </div>
    </div>
  </div>

  <div id="progress-container">
    <div id="progress-bar"><div id="progress-fill"></div></div>
    <div id="progress-label">0%</div>
  </div>

  <div id="view-headline" class="view-headline"></div>

  <div id="profile-container">
    <select id="profile-select" onchange="switchProfile()"></select>
  </div>

  <div id="tracker-content"></div>

  <button class="app-button add-button" id="add-exercise-btn">Add New Exercise</button>
  <button class="app-button reset-button" id="reset-btn">Reset Weekly Progress</button>

  <div class="modal-overlay" id="modal-overlay"></div>
  <div class="modal" id="modal">
    <h3 id="modal-title-ex">Add/Edit Exercise</h3>
    <label class="modal-label" for="ex-name">Exercise Name</label>
    <input class="modal-input" type="text" id="ex-name" placeholder="e.g., Push-ups" />
    <label class="modal-label" for="ex-cat">Category</label>
    <select class="modal-input modal-select" id="ex-cat"></select>
    <label class="modal-label" for="ex-reps">Reps / Duration</label>
    <input class="modal-input" type="text" id="ex-reps" placeholder="e.g., 3x10 or 30s" />
    <label class="modal-label">Sets per Weekday</label>
    <div id="schedule-inputs"></div>
    <div class="modal-actions">
      <button class="modal-button delete" id="delete-btn" style="display:none;">x</button> <button class="modal-button cancel" onclick="closeModal()">Cancel</button>
      <button class="modal-button save" id="save-btn">Save</button>
    </div>
  </div>

  <div class="modal-overlay" id="profile-modal-overlay"></div>
  <div class="modal" id="profile-modal">
    <h3>Manage Profiles</h3>
    <div id="profile-list"></div>
    <input type="text" id="new-profile-name-input" class="modal-input" placeholder="New profile name" style="margin-top: 15px; margin-bottom:10px;">
    <button class="modal-button save" id="add-profile-btn" style="width:100%; margin-bottom:10px;">Add Profile</button>
    <div class="modal-actions" style="justify-content: flex-end;">
        <button class="modal-button cancel" onclick="closeProfileModal()">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="cat-modal-overlay"></div>
  <div class="modal" id="cat-modal">
    <h3>Manage Categories</h3>
    <label class="modal-label">Drag to reorder. Click 'x' to remove (not possible for original presets).</label> <div id="cat-list"></div> <input type="text" id="new-category-name-input" class="modal-input" placeholder="Add new category..." style="margin-top: 15px; margin-bottom:10px;">
    <button class="modal-button save" id="add-cat-btn" style="width:100%; margin-bottom:10px;">Add Category</button> <div class="modal-actions" style="justify-content: flex-end;">
      <button class="modal-button cancel" onclick="closeCatModal()">Close</button>
      </div>
  </div>

<script>
    const WEEKDAYS=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
    const ORIGINAL_PRESET_CATEGORIES=["Daily GTG","Upper Body","Lower Body","Mobility","Core","Conditioning","Skills"]; // Keep original presets separate
    let exercises=[], collapsedCategories={}, editIndex=null;
    let isWeekly=true;

    // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
    let categoryOrder = []; // This will hold the current order of ALL categories
    let dragStartIndex = -1; // For drag and drop

    function loadCategoryOrder() {
        try {
            const storedOrder = localStorage.getItem('categoryOrder');
            if (storedOrder) {
                 categoryOrder = JSON.parse(storedOrder);
                 // Migration or cleanup: ensure categoryOrder only contains strings and no duplicates
                 categoryOrder = Array.from(new Set(categoryOrder.filter(item => typeof item === 'string')));

                 // Ensure all original presets are included if they somehow got removed, append them to the end
                 const currentOrderLower = categoryOrder.map(cat => cat.toLowerCase());
                 ORIGINAL_PRESET_CATEGORIES.forEach(preset => {
                     if (!currentOrderLower.includes(preset.toLowerCase())) {
                         categoryOrder.push(preset);
                     }
                 });

            } else {
                // Initial load: Create order from old customCategories (if any) and presets
                const oldCustomCategories = JSON.parse(localStorage.getItem('customCategories')) || [];
                 // Start with old custom categories, then add presets not already in custom
                categoryOrder = [...oldCustomCategories, ...ORIGINAL_PRESET_CATEGORIES.filter(p => !oldCustomCategories.map(c => c.toLowerCase()).includes(p.toLowerCase()))];
                 // Remove old customCategories from storage after migration
                 localStorage.removeItem('customCategories');
            }
        } catch(e) {
            console.error("Error loading category order:", e);
            categoryOrder = [...ORIGINAL_PRESET_CATEGORIES]; // Fallback to just presets
        }
         saveCategoryOrderToStorage(); // Save the potentially new or corrected order immediately
         console.log("Loaded/Initial Category Order:", categoryOrder); // Log for debugging
    }

     function saveCategoryOrderToStorage() {
        localStorage.setItem('categoryOrder', JSON.stringify(categoryOrder));
         console.log("Saved Category Order:", categoryOrder); // Log for debugging
    }

    // This function now just returns the loaded/saved order
    function allCategories(){ return [...categoryOrder]; } // Return a copy
    // --- DRAG & DROP & CATEGORY MANAGEMENT END ---

    function toggleMenu(){ document.getElementById('dropdown-menu').classList.toggle('show'); }
    function toggleViewMode(){ isWeekly=!isWeekly; document.getElementById('dropdown-menu').classList.remove('show'); renderExercises(); }

    function exportExercises(){
        toggleMenu();
        if (exercises.length === 0 && categoryOrder.length === 0) { // Check categoryOrder too
            alert("No exercises or categories to export for the current profile.");
            return;
        }
        const profileName = currentProfile.replace(/\s+/g, '_');
        const exportData = {
            profileName: currentProfile,
            exercises: exercises,
            categoryOrder: categoryOrder, // Export the category order
            viewSettings: { isWeekly: isWeekly }
        };
        const a=document.createElement('a');
        a.href='data:text/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(exportData));
        a.download= `${profileName}_GTGtracker_export_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
    }

    function importExercises(){
        toggleMenu();
        const inp=document.createElement('input');
        inp.type='file';
        inp.accept='application/json';
        inp.onchange=e=>{
            const f=e.target.files[0];
            if(!f)return;
            const r=new FileReader();
            r.onload=()=>{
                try {
                    const importedData = JSON.parse(r.result);
                    if (importedData && importedData.exercises && Array.isArray(importedData.exercises)) {
                        let importToProfile = currentProfile;
                        let newProfileCreated = false;
                        let profileSwitchConfirmed = false;

                        if (importedData.profileName) {
                            if (!profiles[importedData.profileName]) {
                                if (confirm(`Imported data is for profile "${importedData.profileName}". Create this profile and import data into it?`)) {
                                    profiles[importedData.profileName] = [];
                                    importToProfile = importedData.profileName;
                                    newProfileCreated = true;
                                    profileSwitchConfirmed = true;
                                } else if (confirm(`Import into current profile "${currentProfile}" instead? This will overwrite existing data for "${currentProfile}".`)){
                                    profileSwitchConfirmed = true;
                                } else { return; }
                            } else if (importedData.profileName !== currentProfile) {
                                if (confirm(`Imported data is for profile "${importedData.profileName}". Switch to this profile and overwrite its data?`)) {
                                    importToProfile = importedData.profileName;
                                    profileSwitchConfirmed = true;
                                } else if (confirm(`Import into current profile "${currentProfile}" instead? This will overwrite existing data for "${currentProfile}".`)) {
                                    profileSwitchConfirmed = true;
                                } else { return; }
                            } else {
                                if (!confirm(`This will overwrite all exercises in the current profile "${currentProfile}". Continue?`)) { return; }
                                profileSwitchConfirmed = true;
                            }
                        } else {
                             if (!confirm(`No profile name in import file. Import exercises into current profile "${currentProfile}"? This will overwrite existing data.`)) { return; }
                            profileSwitchConfirmed = true;
                        }

                        if (!profileSwitchConfirmed) return;

                        // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
                        // Handle imported category order
                        if (importedData.categoryOrder && Array.isArray(importedData.categoryOrder)) {
                             if (confirm(`Imported data includes a custom category order. Use this order and merge in any new categories?`)) {
                                 const importedOrder = importedData.categoryOrder.filter(item => typeof item === 'string');
                                 const currentOrderLower = categoryOrder.map(c => c.toLowerCase());

                                 // Add imported categories that are not currently present
                                 importedOrder.forEach(importedCat => {
                                     if (!currentOrderLower.includes(importedCat.toLowerCase())) {
                                         categoryOrder.push(importedCat); // Add new ones to the end initially
                                     }
                                 });

                                 // Now reorder categoryOrder based on the importedOrder sequence
                                 const newCategoryOrder = importedOrder.filter(cat => categoryOrder.map(c => c.toLowerCase()).includes(cat.toLowerCase())); // Start with existing categories from import
                                  // Add any existing categories not in the import to the end
                                  categoryOrder.forEach(currentCat => {
                                      if (!newCategoryOrder.map(c => c.toLowerCase()).includes(currentCat.toLowerCase())) {
                                          newCategoryOrder.push(currentCat);
                                      }
                                  });
                                 categoryOrder = newCategoryOrder; // Apply the merged and reordered list

                                 saveCategoryOrderToStorage(); // Save the merged/reordered categories
                                 populateCatModal(); // Refresh modal if open
                                 populateExerciseCategoryDropdown(); // Update dropdown
                             } else {
                                  // User chose not to use imported order, keep current categoryOrder state
                                  // Still need to ensure imported exercises' categories exist in categoryOrder
                                   importedData.exercises.forEach(ex => {
                                       if (ex.category) {
                                           const catExists = categoryOrder.some(c => c.toLowerCase() === ex.category.toLowerCase());
                                           if (!catExists) {
                                                if (confirm(`The exercise "${ex.name}" uses category "${ex.category}" which is not in your list. Add "${ex.category}"?`)) {
                                                     categoryOrder.push(ex.category); // Add new exercise category to the end
                                                     saveCategoryOrderToStorage();
                                                     populateCatModal();
                                                     populateExerciseCategoryDropdown();
                                                }
                                           }
                                       }
                                   });
                             }
                        } else {
                             // No categoryOrder in import, just ensure exercise categories exist
                             importedData.exercises.forEach(ex => {
                                if (ex.category) {
                                    const catExists = categoryOrder.some(c => c.toLowerCase() === ex.category.toLowerCase());
                                    if (!catExists) {
                                         if (confirm(`The exercise "${ex.name}" uses category "${ex.category}" which is not in your list. Add "${ex.category}"?`)) {
                                             categoryOrder.push(ex.category); // Add new exercise category to the end
                                             saveCategoryOrderToStorage();
                                             populateCatModal();
                                             populateExerciseCategoryDropdown();
                                         }
                                    }
                                }
                             });
                        }
                        // --- DRAG & DROP & CATEGORY MANAGEMENT END ---


                        currentProfile = importToProfile;
                        localStorage.setItem("currentProfile", currentProfile);
                        exercises = importedData.exercises.map(ensureScheduleFormat);
                        profiles[currentProfile] = exercises;
                        localStorage.setItem("profiles", JSON.stringify(profiles));

                        if (newProfileCreated || importedData.profileName !== document.getElementById("profile-select").value) {
                            loadProfileOptions();
                        }
                        document.getElementById('profile-select').value = currentProfile;

                        if (importedData.viewSettings && typeof importedData.viewSettings.isWeekly === 'boolean') {
                            isWeekly = importedData.viewSettings.isWeekly;
                            localStorage.setItem('isWeeklyView', isWeekly); // Save imported view mode
                        }
                        renderExercises();
                        // populateExerciseCategoryDropdown(); // Called during category import handling
                        alert("Data imported successfully to profile: " + currentProfile + "!");
                    } else { alert("Invalid file format. Expected 'exercises' array."); }
                } catch (err) { alert("Error importing file: " + err.message); console.error("Import error:", err); }
            };
            r.readAsText(f);
        };
        inp.click();
    }

    function clearExercises(){
        toggleMenu();
        if (exercises.length === 0) { alert("No exercises to clear."); return; }
        if(confirm(`Are you sure you want to clear all exercises for the current profile "${currentProfile}"? This cannot be undone.`)){
            exercises=[]; saveExercises(); renderExercises();
        }
    }
    function openCatModal(){
        document.getElementById('dropdown-menu').classList.remove('show');
        document.getElementById('cat-modal-overlay').classList.add('active');
        document.getElementById('cat-modal').classList.add('active');
        populateCatModal();
    }
    function closeCatModal(){
        document.getElementById('cat-modal-overlay').classList.remove('active');
        document.getElementById('cat-modal').classList.remove('active');
        populateExerciseCategoryDropdown(); // Refresh dropdown in case categories changed
        renderExercises(); // Refresh main view in case order changed
    }
    function showAbout(){
        toggleMenu();
        alert('Training Arc - GtG Loop Tracker\n\nBeta Version 1.2 (UI & Management Overhaul)\nA loop tracker for daily habits.\nProgress is saved locally.\n\nby Sascha Leng');
    }

    // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
    function populateCatModal() {
        const list = document.getElementById('cat-list');
        list.innerHTML = '';

        if (categoryOrder.length === 0) {
             list.innerHTML = `<p style="text-align:center; color:#777; margin-top:10px;">No categories defined. Add one below!</p>`;
             return;
        }

        categoryOrder.forEach((catName) => { // Iterate directly over the order array
            const originalCategoryName = catName; // For closure

            const item = document.createElement('div');
            item.className = 'modal-item';
            item.setAttribute('draggable', true); // Make the item draggable
            item.setAttribute('data-name', originalCategoryName); // Store the category name for drag/drop

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalCategoryName;
            nameSpan.style.flexGrow = "1";

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'modal-input list-rename-input';
            nameInput.value = originalCategoryName;
            nameInput.style.display = 'none';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.className = 'modal-button';

            const saveRenameBtn = document.createElement('button');
            saveRenameBtn.textContent = 'Save';
            saveRenameBtn.className = 'modal-button save';
            saveRenameBtn.style.display = 'none';

            const cancelRenameBtn = document.createElement('button');
            cancelRenameBtn.textContent = 'Cancel';
            cancelRenameBtn.className = 'modal-button cancel';
            cancelRenameBtn.style.display = 'none';

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'x';
            deleteBtn.className = 'modal-button delete';
            // Disable delete for original preset categories
            deleteBtn.disabled = ORIGINAL_PRESET_CATEGORIES.map(p => p.toLowerCase()).includes(originalCategoryName.toLowerCase());


            const controlsDiv = document.createElement('div');
            controlsDiv.style.display = 'flex';
            controlsDiv.style.alignItems = 'center';
            controlsDiv.style.gap = '8px';
            controlsDiv.appendChild(renameBtn);
            controlsDiv.appendChild(saveRenameBtn);
            controlsDiv.appendChild(cancelRenameBtn);
            controlsDiv.appendChild(deleteBtn);

            item.appendChild(nameSpan);
            item.appendChild(nameInput);
            item.appendChild(controlsDiv);
            list.appendChild(item);

            nameInput.onfocus = () => { item.setAttribute('draggable', false); };
            nameInput.onblur = () => { item.setAttribute('draggable', true); };


            renameBtn.onclick = () => {
                 // Disable dragging while editing
                 item.setAttribute('draggable', false);
                nameSpan.style.display = 'none';
                nameInput.style.display = 'block'; nameInput.style.flexGrow = '1';
                nameInput.value = nameSpan.textContent; nameInput.focus();
                renameBtn.style.display = 'none';
                saveRenameBtn.style.display = 'inline-block';
                cancelRenameBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            };

            cancelRenameBtn.onclick = () => {
                 // Re-enable dragging
                 item.setAttribute('draggable', true);
                nameSpan.style.display = 'block';
                nameInput.style.display = 'none';
                renameBtn.style.display = 'inline-block';
                saveRenameBtn.style.display = 'none';
                cancelRenameBtn.style.display = 'none';
                deleteBtn.style.display = 'inline-block';
            };

            saveRenameBtn.onclick = () => {
                const newNameTrimmed = nameInput.value.trim();
                if (!newNameTrimmed) {
                    alert("Category name cannot be empty."); nameInput.focus(); return;
                }
                const newNameLower = newNameTrimmed.toLowerCase();
                const originalNameLower = originalCategoryName.toLowerCase();

                if (newNameLower === originalNameLower && newNameTrimmed === originalCategoryName) {
                    cancelRenameBtn.onclick(); return; // No change
                }

                 // Check for conflicts in the *entire* categoryOrder list
                const conflict = categoryOrder.some(cat => cat.toLowerCase() === newNameLower && cat.toLowerCase() !== originalNameLower);

                if (conflict) {
                    alert(`Category name "${newNameTrimmed}" already exists.`);
                    nameInput.focus(); return;
                }

                // Update exercises using the old category name
                exercises.forEach(ex => {
                    if (ex.category === originalCategoryName) {
                        ex.category = newNameTrimmed;
                    }
                });
                saveExercises(); // Save exercises with updated category names

                // Update the categoryOrder array by finding the old name and replacing it
                const oldIndex = categoryOrder.indexOf(originalCategoryName);
                if(oldIndex !== -1) {
                    categoryOrder[oldIndex] = newNameTrimmed;
                    saveCategoryOrderToStorage();
                    alert(`Category "${originalCategoryName}" renamed to "${newNameTrimmed}".`);
                    populateCatModal(); // Refresh this modal's list
                    // populateExerciseCategoryDropdown and renderExercises called when modal closes
                } else {
                     console.error("Category not found in order array during rename:", originalCategoryName);
                      cancelRenameBtn.onclick(); // Revert UI if not found in array
                }
            };

            deleteBtn.onclick = () => {
                 if (deleteBtn.disabled) {
                     alert("Original preset categories cannot be removed.");
                     return;
                 }
                if (confirm(`Remove category "${originalCategoryName}"? Exercises using this category will need their category reassigned manually later if desired.`)) {
                    // Find the index by name in the current order array
                    const indexToDelete = categoryOrder.indexOf(originalCategoryName);
                    if(indexToDelete !== -1) {
                         categoryOrder.splice(indexToDelete, 1);
                         saveCategoryOrderToStorage();
                         populateCatModal(); // Refresh this modal's list
                         // populateExerciseCategoryDropdown and renderExercises called when modal closes
                    } else {
                         console.error("Category not found in order array for deletion:", originalCategoryName);
                         populateCatModal(); // Just refresh in case of discrepancy
                    }
                }
            };
        });
        document.getElementById('new-category-name-input').value = '';
    }


    document.getElementById('add-cat-btn').onclick=()=>{
        const newCatNameInput = document.getElementById('new-category-name-input');
        const newCatName = newCatNameInput.value.trim();
        if (!newCatName) {
            alert("Please enter a category name."); return;
        }
        const lowerNewCatName = newCatName.toLowerCase();
        // Check for duplicates in the entire categoryOrder list
        if (categoryOrder.map(c=>c.toLowerCase()).includes(lowerNewCatName)) {
            alert(`Category "${newCatName}" already exists.`);
        } else {
            categoryOrder.push(newCatName); // Add to the end
            saveCategoryOrderToStorage();
            populateCatModal(); // Refresh the modal list to show the new item
            // populateExerciseCategoryDropdown and renderExercises called when modal closes
            newCatNameInput.value = '';
        }
    };
    document.getElementById('cat-modal-overlay').onclick=closeCatModal;

    // Drag & Drop Event Listeners on the cat-list container
    const catListElement = document.getElementById('cat-list');

    catListElement.addEventListener('dragstart', (e) => {
        const targetItem = e.target.closest('.modal-item');
        if (!targetItem || !targetItem.draggable) return; // Only drag draggable items

        const categoryName = targetItem.getAttribute('data-name');
        dragStartIndex = categoryOrder.indexOf(categoryName); // Get index from the actual order array

        if (dragStartIndex === -1) { // Should not happen if logic is correct
             e.preventDefault(); return;
        }

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', categoryName); // Pass the category name or index
        targetItem.classList.add('dragging');
    });

    catListElement.addEventListener('dragover', (e) => {
        e.preventDefault(); // Necessary to allow dropping
        e.dataTransfer.dropEffect = 'move';

        const targetItem = e.target.closest('.modal-item');
        // Find the actual item element, not its children, and ensure it's in the list and not the item being dragged
        if (!targetItem || !catListElement.contains(targetItem) || targetItem.classList.contains('dragging')) {
             // Clear drag-over classes if not hovering over a valid target item
             catListElement.querySelectorAll('.modal-item').forEach(item => {
                 item.classList.remove('drag-over-before', 'drag-over-after');
             });
             return;
         }

        // Remove existing drag-over classes from all items
        catListElement.querySelectorAll('.modal-item').forEach(item => {
            item.classList.remove('drag-over-before', 'drag-over-after');
        });

        // Determine if dragging before or after the target item
        const targetRect = targetItem.getBoundingClientRect();
        const targetMiddleY = targetRect.top + targetRect.height / 2;

        if (e.clientY < targetMiddleY) {
            targetItem.classList.add('drag-over-before');
        } else {
             targetItem.classList.add('drag-over-after');
        }
    });

    catListElement.addEventListener('dragleave', (e) => {
         // Only remove class if leaving the list item itself, not just moving within it
         const targetItem = e.target.closest('.modal-item');
         if (targetItem && catListElement.contains(targetItem) && !targetItem.contains(e.relatedTarget)) {
             targetItem.classList.remove('drag-over-before', 'drag-over-after');
         } else if (!catListElement.contains(e.relatedTarget)) {
              // Left the entire list container
             catListElement.querySelectorAll('.modal-item').forEach(item => {
                 item.classList.remove('drag-over-before', 'drag-over-after');
             });
         }
    });


    catListElement.addEventListener('drop', (e) => {
        e.preventDefault();
        const dragItemElement = catListElement.querySelector('.modal-item.dragging'); // The DOM element being dragged
        const targetItemElement = e.target.closest('.modal-item'); // The DOM element being dropped onto

        // Remove drag-over classes from all items
        catListElement.querySelectorAll('.modal-item').forEach(item => {
            item.classList.remove('drag-over-before', 'drag-over-after');
        });

        if (!dragItemElement || !targetItemElement || !catListElement.contains(targetItemElement) || dragItemElement === targetItemElement) return;

        const draggedCategoryName = dragItemElement.getAttribute('data-name');
        const targetCategoryName = targetItemElement.getAttribute('data-name');

        const dragIndex = categoryOrder.indexOf(draggedCategoryName);
        let dropIndex = categoryOrder.indexOf(targetCategoryName);

        if (dragIndex === -1 || dropIndex === -1) { // Should not happen
             console.error("Dragged or target category not found in order array.");
             return;
        }

         // Adjust dropIndex based on whether we're dropping before or after the target
        const targetRect = targetItemElement.getBoundingClientRect();
        const targetMiddleY = targetRect.top + targetRect.height / 2;
        if (e.clientY > targetMiddleY) {
            // Dropping after the target item
            dropIndex++;
        }

        // Ensure dropIndex is not out of bounds after incrementing
         dropIndex = Math.min(dropIndex, categoryOrder.length);


        // Perform the move in the categoryOrder array
        // 1. Remove the dragged item from its original position
        const [movedCategory] = categoryOrder.splice(dragIndex, 1);

        // 2. Insert the dragged item at the new position
        categoryOrder.splice(dropIndex, 0, movedCategory);

        saveCategoryOrderToStorage(); // Save the new order
        populateCatModal(); // Re-render the list to reflect the new order
        // populateExerciseCategoryDropdown() and renderExercises() called when modal closes
    });

    catListElement.addEventListener('dragend', (e) => {
        const dragItem = catListElement.querySelector('.modal-item.dragging');
        if (dragItem) {
            dragItem.classList.remove('dragging');
        }
         // Also ensure drag-over classes are removed on drag end
         catListElement.querySelectorAll('.modal-item').forEach(item => {
             item.classList.remove('drag-over-before', 'drag-over-after');
         });
        dragStartIndex = -1; // Reset drag start index
    });
    // --- DRAG & DROP & CATEGORY MANAGEMENT END ---


    function populateExerciseCategoryDropdown() {
        const catSel = document.getElementById('ex-cat');
        const currentCatValue = catSel.value; // Preserve current selection if possible
        catSel.innerHTML = ''; // Clear existing options

        const categoriesToDisplay = allCategories(); // Use the categoryOrder

        if (categoriesToDisplay.length === 0) {
            catSel.innerHTML = '<option value="">No Categories Available</option>';
             // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
             // Disable the select if no categories
            catSel.disabled = true;
             // --- DRAG & DROP & CATEGORY MANAGEMENT END ---
            return;
        }

         // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
        catSel.disabled = false;
         // --- DRAG & DROP & CATEGORY MANAGEMENT END ---

        categoriesToDisplay.forEach(c => {
            catSel.add(new Option(c, c));
        });

        // Try to reselect previous value, or first if not found
        if (categoriesToDisplay.map(c => c.toLowerCase()).includes(currentCatValue.toLowerCase())) {
            const actualCat = categoriesToDisplay.find(c => c.toLowerCase() === currentCatValue.toLowerCase());
            catSel.value = actualCat || categoriesToDisplay[0];
        } else {
            catSel.selectedIndex = 0; // Default to first
        }
    }

    document.getElementById('delete-btn').onclick=()=>{
        if(editIndex!==null && confirm('Are you sure you want to delete this exercise?')){
            exercises.splice(editIndex,1); saveExercises(); closeModal(); renderExercises();
        }
    };

    function openModal(idx=null){
        editIndex=idx;
        document.getElementById('modal-overlay').classList.add('active');
        document.getElementById('modal').classList.add('active');
        const nameInput=document.getElementById('ex-name');
        const catSel=document.getElementById('ex-cat');
        const repsInput=document.getElementById('ex-reps');
        const modalTitle = document.getElementById('modal-title-ex');

        populateExerciseCategoryDropdown(); // Ensure dropdown is fresh

        if(idx!==null){ // Editing existing exercise
            modalTitle.textContent = "Edit Exercise";
            const ex=exercises[idx];
            nameInput.value=ex.name;

            // Set category, handle if category was renamed/deleted
            const currentExerciseCategory = ex.category || "";
            const availableCategories = allCategories(); // Use the categoryOrder
            const categoryExists = availableCategories.some(c => c.toLowerCase() === currentExerciseCategory.toLowerCase());

            if (categoryExists) {
                const actualCat = availableCategories.find(c => c.toLowerCase() === currentExerciseCategory.toLowerCase());
                catSel.value = actualCat;
            } else if (availableCategories.length > 0) {
                catSel.selectedIndex = 0; // Default to first if current doesn't exist
                // Optionally alert user: alert(`Category "${currentExerciseCategory}" no longer exists. Please select a new one.`);
            } else {
                // catSel already shows "No Categories Available" from populateExerciseCategoryDropdown
            }

            repsInput.value=ex.reps||'';
            document.getElementById('delete-btn').style.display='inline-block';
        } else { // Adding new exercise
            modalTitle.textContent = "Add Exercise";
            nameInput.value='';
            if (allCategories().length > 0) catSel.selectedIndex = 0;
            // else catSel shows "No Categories Available"
            repsInput.value='';
            document.getElementById('delete-btn').style.display='none';
        }
        const schedDiv=document.getElementById('schedule-inputs');
        schedDiv.innerHTML='';
        WEEKDAYS.forEach((day,i)=>{
            const dayContainer = document.createElement('div');
            const lbl=document.createElement('label');
            lbl.className='modal-label'; lbl.textContent=day; lbl.htmlFor = `sch_${i}`;
            const num=document.createElement('input');
            num.type='number'; num.min='0'; num.max='20';
            num.className='modal-number modal-input'; num.id=`sch_${i}`;
            num.value=(idx!==null && exercises[idx].schedule && exercises[idx].schedule[i]) ? exercises[idx].schedule[i] : 0;
            dayContainer.appendChild(lbl); dayContainer.appendChild(num);
            schedDiv.appendChild(dayContainer);
        });
    }
    function closeModal(){
        document.getElementById('modal-overlay').classList.remove('active');
        document.getElementById('modal').classList.remove('active');
        editIndex = null;
    }
    document.getElementById('add-exercise-btn').onclick=()=>openModal(null);
    document.getElementById('modal-overlay').onclick=closeModal;

    document.getElementById('save-btn').onclick=()=>{
        const name=document.getElementById('ex-name').value.trim();
        if(!name){ alert("Please enter an exercise name."); return; }
        const category=document.getElementById('ex-cat').value;
        if(!category || category === "" || category === "No Categories Available"){ alert("Please select or create a category."); return; }
        const reps=document.getElementById('ex-reps').value.trim();
        const sched={};
        WEEKDAYS.forEach((_,i)=>{
            const valInput = document.getElementById(`sch_${i}`);
            if (valInput) {
                const v=parseInt(valInput.value)||0;
                if(v>0) sched[i]=v;
            }
        });
        if(Object.keys(sched).length === 0 && !confirm("This exercise has no scheduled days. Save anyway?")) return;
        const obj={name,category,reps,schedule:sched,progress:{}};
        if(editIndex!==null) exercises[editIndex]=obj;
        else exercises.push(obj);
        saveExercises(); closeModal(); renderExercises();
    };
    document.getElementById('reset-btn').onclick=()=>{
        if (exercises.length === 0) { alert("No exercises to reset."); return; }
        if(confirm('Are you sure you want to reset all progress for the current profile?')){
            exercises.forEach(e=>e.progress={});
            saveExercises(); renderExercises();
        }
    };

    function renderExercises(){
        document.getElementById('view-headline').textContent = isWeekly ? 'Weekly Planner' : 'Exercise Overview';
        const c=document.getElementById('tracker-content');
        c.innerHTML='';
        if (exercises.length === 0) {
            c.innerHTML = `<p style="text-align:center; color:#777; margin-top:30px;">No exercises for "${currentProfile}". Click "Add New Exercise".</p>`;
            updateProgress(); return;
        }
        if(isWeekly) renderWeekly(c);
        else renderByCategory(c);
        updateProgress();
    }

    function renderByCategory(cont){
        const groupedExercises = {};
        const categoriesInOrder = allCategories(); // Use the categoryOrder

        // Initialize groups based on the current order
        categoriesInOrder.forEach(cat => groupedExercises[cat] = []);
        // Add a group for uncategorized exercises
        const uncategorizedName = "Uncategorized";
         groupedExercises[uncategorizedName] = [];


        exercises.forEach((ex, idx) => {
            // Find the canonical category name (case-insensitive match) in the *current* categoryOrder
            const canonicalCat = categoriesInOrder.find(c => c.toLowerCase() === (ex.category || "").toLowerCase());

            if (canonicalCat) {
                 // Add exercise to the correctly cased canonical category group
                 if (!groupedExercises[canonicalCat]) groupedExercises[canonicalCat] = []; // Should exist, but defensive
                 groupedExercises[canonicalCat].push({ e: ex, idx });
            } else {
                // Handle exercises with a category that no longer exists in categoryOrder
                 groupedExercises[uncategorizedName].push({ e: ex, idx });
            }
        });

        // Render categories in the specified order
        categoriesInOrder.forEach(cat=>{
            const items = groupedExercises[cat];
            if(!items || items.length === 0) return; // Skip if no exercises in this category

            const h=document.createElement('div');
            h.className='section-header';
            // Use category name for collapsedCategories key
            h.onclick=()=>{
                collapsedCategories[cat]=!collapsedCategories[cat];
                localStorage.setItem('collapsedCategories',JSON.stringify(collapsedCategories));
                renderExercises();
            };
            h.innerHTML=`<h2>${cat}</h2><span>${collapsedCategories[cat]?'+':'-'}</span>`;
            cont.appendChild(h);
            if(!collapsedCategories[cat]){
                const d=document.createElement('div');
                d.className='section-content';
                items.forEach(({e, idx}) => d.appendChild(renderExerciseRow(e, idx)));
                cont.appendChild(d);
            }
        });

         // Always render Uncategorized at the end if it has exercises
        if (groupedExercises[uncategorizedName].length > 0) {
             const items = groupedExercises[uncategorizedName];
             const h=document.createElement('div');
            h.className='section-header';
            // Use "Uncategorized" as the key for collapsed state
            h.onclick=()=>{
                collapsedCategories[uncategorizedName]=!collapsedCategories[uncategorizedName];
                localStorage.setItem('collapsedCategories',JSON.stringify(collapsedCategories));
                renderExercises();
            };
            h.innerHTML=`<h2>${uncategorizedName}</h2><span>${collapsedCategories[uncategorizedName]?'+':'-'}</span>`;
            cont.appendChild(h);
            if(!collapsedCategories[uncategorizedName]){
                const d=document.createElement('div');
                d.className='section-content';
                items.forEach(({e,idx})=>d.appendChild(renderExerciseRow(e, idx)));
                cont.appendChild(d);
            }
        }
    }

    function renderWeekly(cont){
        const byDay={};
        WEEKDAYS.forEach(d=>byDay[d]=[]);
        exercises.forEach((e,idx)=>{
            if (e.schedule) {
                Object.entries(e.schedule).forEach(([dayIndex,count])=>{
                    const dayIndexInt = parseInt(dayIndex);
                    if(!isNaN(dayIndexInt) && WEEKDAYS[dayIndexInt] && count > 0) {
                       byDay[WEEKDAYS[dayIndexInt]].push({e, idx, count});
                    }
                });
            }
        });
        WEEKDAYS.forEach(day=>{
            const dayItems = byDay[day];
            if(!dayItems.length)return;
            const h=document.createElement('div');
            h.className='section-header';
            // Use day name for collapsedCategories key
            h.onclick=()=>{
                collapsedCategories[day]=!collapsedCategories[day];
                localStorage.setItem('collapsedCategories',JSON.stringify(collapsedCategories));
                renderExercises();
            };
            h.innerHTML=`<h2>${day}</h2><span>${collapsedCategories[day]?'+':'-'}</span>`;
            cont.appendChild(h);
            if(!collapsedCategories[day]){
                const d=document.createElement('div');
                d.className='section-content';
                dayItems.forEach(({e,idx,count,dayKey})=>d.appendChild(renderExerciseRow(e,idx,count,day)));
                cont.appendChild(d);
            }
        });
    }

    function renderExerciseRow(exercise, index, repsCountForDay, dayKey){
        const row=document.createElement('div'); row.className='exercise-row';
        const headerRow=document.createElement('div'); headerRow.className='header-row';
        const nameDiv=document.createElement('div'); nameDiv.className='name'; nameDiv.textContent=exercise.name;
        const controlsDiv = document.createElement('div');
        const editBtn=document.createElement('button');
        editBtn.className='edit-button'; editBtn.textContent='edit';
        editBtn.onclick=(e)=>{ e.stopPropagation(); openModal(index); };
        controlsDiv.appendChild(editBtn);
        headerRow.appendChild(nameDiv); headerRow.appendChild(controlsDiv);
        row.appendChild(headerRow);

        if(exercise.reps){
            const repsDurationDiv=document.createElement('div');
            repsDurationDiv.className='reps-duration'; repsDurationDiv.textContent=exercise.reps;
            row.appendChild(repsDurationDiv);
        }
        const checkboxGroupOuter = document.createElement('div');

        if(isWeekly && dayKey != null && repsCountForDay != null){
            const checkboxGroup=document.createElement('div'); checkboxGroup.className='checkbox-group';
            for(let k=0;k<repsCountForDay;k++){
                const cb=document.createElement('input'); cb.type='checkbox';
                const progressKey=`${dayKey}-${index}-${k}`;
                cb.checked=!!(exercise.progress&&exercise.progress[progressKey]);
                cb.onchange=()=>{
                    exercise.progress=exercise.progress||{};
                    exercise.progress[progressKey]=cb.checked;
                    saveExercises(); updateProgress();
                };
                checkboxGroup.appendChild(cb);
            }
            if (checkboxGroup.hasChildNodes()) checkboxGroupOuter.appendChild(checkboxGroup);
        } else if (!isWeekly) {
            let totalScheduledSets = 0;
            if(exercise.schedule) Object.values(exercise.schedule).forEach(count => totalScheduledSets += count);

            if (totalScheduledSets > 0) {
                Object.entries(exercise.schedule).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).forEach(([dayIndexStr,count])=>{
                    const dayIndex = parseInt(dayIndexStr);
                    if (count > 0 && dayIndex >= 0 && dayIndex < WEEKDAYS.length) {
                        const weekdayRow = document.createElement('div'); weekdayRow.className = 'weekday-row';
                        const weekdayLabel = document.createElement('span');
                        weekdayLabel.className = 'weekday-label'; weekdayLabel.textContent = WEEKDAYS[dayIndex];
                        const singleDayCheckboxGroup = document.createElement('div'); singleDayCheckboxGroup.className = 'checkbox-group';
                        for(let k=0;k<count;k++){
                            const cb=document.createElement('input'); cb.type='checkbox';
                            const currentDayKey = WEEKDAYS[dayIndex];
                            const progressKey=`${currentDayKey}-${index}-${k}`;
                            cb.checked=!!(exercise.progress&&exercise.progress[progressKey]);
                            cb.onchange=()=>{
                                exercise.progress=exercise.progress||{};
                                exercise.progress[progressKey]=cb.checked;
                                saveExercises(); updateProgress();
                            };
                            singleDayCheckboxGroup.appendChild(cb);
                        }
                        weekdayRow.appendChild(weekdayLabel); weekdayRow.appendChild(singleDayCheckboxGroup);
                        checkboxGroupOuter.appendChild(weekdayRow);
                    }
                });
            } else {
                 const noScheduleInfo = document.createElement('div');
                 noScheduleInfo.className = 'reps-duration'; noScheduleInfo.textContent = 'Not scheduled.';
                 noScheduleInfo.style.fontStyle = 'italic'; checkboxGroupOuter.appendChild(noScheduleInfo);
            }
        }
        if (checkboxGroupOuter.hasChildNodes()) row.appendChild(checkboxGroupOuter);
        return row;
    }

    function updateProgress(){
        let totalSets=0, completedSets=0;
        exercises.forEach((ex, exerciseIdx) => {
            if (ex.schedule) {
                Object.entries(ex.schedule).forEach(([dayIndexStr, setCount]) => {
                    const dayIndex = parseInt(dayIndexStr);
                    if (!isNaN(dayIndex) && dayIndex >= 0 && dayIndex < WEEKDAYS.length) {
                        totalSets += setCount;
                        const dayKey = WEEKDAYS[dayIndex];
                        if (dayKey) {
                            for (let k = 0; k < setCount; k++) {
                                const progressKey = `${dayKey}-${exerciseIdx}-${k}`;
                                if (ex.progress && ex.progress[progressKey]) completedSets++;
                            }
                        }
                    }
                });
            }
        });
        const percentage = totalSets > 0 ? Math.round((completedSets / totalSets) * 100) : 0;
        document.getElementById('progress-fill').style.width = percentage + '%';
        document.getElementById('progress-label').textContent = percentage + '%';
    }

    function ensureScheduleFormat(ex) {
        if (!ex.schedule || typeof ex.schedule !== 'object') {
            ex.schedule = {};
        }
        const newSchedule = {};
        for (const dayIdxStr in ex.schedule) {
            const dayIdx = parseInt(dayIdxStr);
            const count = parseInt(ex.schedule[dayIdxStr]);
            if (!isNaN(dayIdx) && dayIdx >= 0 && dayIdx < WEEKDAYS.length && !isNaN(count) && count > 0) {
                newSchedule[dayIdx] = count;
            }
        }
        ex.schedule = newSchedule;
        if (!ex.progress || typeof ex.progress !== 'object') ex.progress = {};
        // Clean up old/unused properties if they exist
        delete ex.weekdays;
        if (ex.days && Array.isArray(ex.days)) { // Migrate old days array format to schedule object if found
             if (Object.keys(ex.schedule).length === 0) { // Only migrate if schedule is empty
                ex.days.forEach(dayIdx => {
                    if (!isNaN(dayIdx) && dayIdx >= 0 && dayIdx < WEEKDAYS.length) {
                        ex.schedule[dayIdx] = 1; // Assume 1 set if migrating from old format
                    }
                });
             }
             delete ex.days;
        }
        return ex;
    }

    document.addEventListener('click', function(event) {
        const menu = document.getElementById('dropdown-menu');
        const icon = document.querySelector('.menu-icon');
        if (menu && icon && menu.classList.contains('show') &&
            !icon.contains(event.target) && !menu.contains(event.target)) {
            menu.classList.remove('show');
        }
    });

    let profiles = {};
    let currentProfile = "Default";

    function loadProfiles() {
        const storedProfiles = localStorage.getItem("profiles");
        if (storedProfiles) {
            try { profiles = JSON.parse(storedProfiles); } catch(e) { profiles = {"Default": []}; console.error("Error parsing profiles from localStorage", e); }
        } else {
            profiles = { "Default": [] };
        }
        currentProfile = localStorage.getItem("currentProfile") || Object.keys(profiles)[0] || "Default";
        if (!profiles[currentProfile]) {
            currentProfile = Object.keys(profiles)[0] || "Default";
            if (!profiles[currentProfile] && Object.keys(profiles).length === 0) { // If profiles is truly empty
                 profiles["Default"] = [];
                 currentProfile = "Default";
            }
            localStorage.setItem("currentProfile", currentProfile);
        }
         if (Object.keys(profiles).length === 0) { // Absolute fallback
            profiles["Default"] = [];
            currentProfile = "Default";
            localStorage.setItem("currentProfile", currentProfile);
            localStorage.setItem("profiles", JSON.stringify(profiles));
        }
    }

    function loadProfileOptions() {
        const sel = document.getElementById("profile-select");
        sel.innerHTML = '';
        const sortedProfileNames = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()));


        if (sortedProfileNames.length === 0) { // Should be caught by loadProfiles
            profiles["Default"] = []; currentProfile = "Default";
            localStorage.setItem("currentProfile", currentProfile); localStorage.setItem("profiles", JSON.stringify(profiles));
            sortedProfileNames.push("Default");
        }

        sortedProfileNames.forEach(name => {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            sel.appendChild(option);
        });
        sel.value = currentProfile;
        document.getElementById('profile-container').style.display = 'flex'; // Always show if it exists
    }

    function switchProfile() {
        const selectedProfileName = document.getElementById("profile-select").value;
        if (selectedProfileName && profiles.hasOwnProperty(selectedProfileName)) {
            currentProfile = selectedProfileName;
            localStorage.setItem("currentProfile", currentProfile);
            exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);
            renderExercises();
            populateExerciseCategoryDropdown();
        } else if (Object.keys(profiles).length > 0) { // Fallback to first profile (alphabetical)
            currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0];
            localStorage.setItem("currentProfile", currentProfile);
            document.getElementById("profile-select").value = currentProfile;
            exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);
            renderExercises(); populateExerciseCategoryDropdown();
        } else { // Should not be reached if loadProfiles ensures Default exists
            console.error("No profiles available to switch to.");
        }
    }

    function saveExercises() {
        if (!profiles[currentProfile]) profiles[currentProfile] = [];
        profiles[currentProfile] = exercises.map(ensureScheduleFormat);
        localStorage.setItem("profiles", JSON.stringify(profiles));
    }

    function openProfileModal() {
        document.getElementById('dropdown-menu').classList.remove('show');
        document.getElementById('profile-modal-overlay').classList.add('active');
        document.getElementById('profile-modal').classList.add('active');
        populateProfileModal();
    }
    function closeProfileModal() {
        document.getElementById('profile-modal-overlay').classList.remove('active');
        document.getElementById('profile-modal').classList.remove('active');
    }

    function populateProfileModal() {
        const list = document.getElementById('profile-list');
        list.innerHTML = '';
        const sortedProfileNames = Object.keys(profiles).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

        sortedProfileNames.forEach(name => {
            const originalName = name;

            const item = document.createElement('div');
            item.className = 'modal-item';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalName;
            nameSpan.style.flexGrow = "1";

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'modal-input list-rename-input';
            nameInput.value = originalName;
            nameInput.style.display = 'none';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.className = 'modal-button';

            const saveRenameBtn = document.createElement('button');
            saveRenameBtn.textContent = 'Save';
            saveRenameBtn.className = 'modal-button save';
            saveRenameBtn.style.display = 'none';

            const cancelRenameBtn = document.createElement('button');
            cancelRenameBtn.textContent = 'Cancel';
            cancelRenameBtn.className = 'modal-button cancel';
            cancelRenameBtn.style.display = 'none';

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'x';
            deleteBtn.className = 'modal-button delete';
            deleteBtn.disabled = (Object.keys(profiles).length <= 1); // Disable delete if only one profile exists

            const controlsDiv = document.createElement('div'); // To group buttons
            controlsDiv.style.display = 'flex'; controlsDiv.style.alignItems = 'center'; controlsDiv.style.gap = '8px';
            controlsDiv.appendChild(renameBtn); controlsDiv.appendChild(saveRenameBtn);
            controlsDiv.appendChild(cancelRenameBtn); controlsDiv.appendChild(deleteBtn);

            item.appendChild(nameSpan); item.appendChild(nameInput); item.appendChild(controlsDiv);
            list.appendChild(item);

            renameBtn.onclick = () => {
                nameSpan.style.display = 'none';
                nameInput.style.display = 'block'; nameInput.style.flexGrow = '1';
                nameInput.value = nameSpan.textContent; nameInput.focus();
                renameBtn.style.display = 'none';
                saveRenameBtn.style.display = 'inline-block';
                cancelRenameBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            };
            cancelRenameBtn.onclick = () => {
                nameSpan.style.display = 'block';
                nameInput.style.display = 'none';
                renameBtn.style.display = 'inline-block';
                saveRenameBtn.style.display = 'none';
                cancelRenameBtn.style.display = 'none';
                deleteBtn.style.display = 'inline-block';
            };
            saveRenameBtn.onclick = () => {
                const newNameTrimmed = nameInput.value.trim();
                if (!newNameTrimmed) {
                    alert("Profile name cannot be empty."); nameInput.focus(); return;
                }
                if (newNameTrimmed.toLowerCase() === originalName.toLowerCase() && newNameTrimmed === originalName) {
                    cancelRenameBtn.onclick(); return;
                }
                for (const existingProfileName in profiles) {
                    if (existingProfileName.toLowerCase() === newNameTrimmed.toLowerCase() && existingProfileName.toLowerCase() !== originalName.toLowerCase()) {
                        alert(`Profile name "${newNameTrimmed}" already exists or conflicts with another profile.`);
                        nameInput.focus(); return;
                    }
                }
                 // Case-insensitive rename check passed, perform the rename
                const profileData = profiles[originalName];
                delete profiles[originalName];
                profiles[newNameTrimmed] = profileData;
                if (currentProfile === originalName) {
                    currentProfile = newNameTrimmed;
                    localStorage.setItem("currentProfile", currentProfile);
                }
                localStorage.setItem("profiles", JSON.stringify(profiles));
                alert(`Profile "${originalName}" renamed to "${newNameTrimmed}".`);
                populateProfileModal(); loadProfileOptions();
                if (document.getElementById("profile-select").value !== currentProfile) {
                    document.getElementById("profile-select").value = currentProfile;
                }
                if (currentProfile === newNameTrimmed && exercises === profileData) { // if current profile data was affected
                    renderExercises();
                }
            };
            deleteBtn.onclick = function() {
                if (deleteBtn.disabled) { alert("Cannot delete the last profile."); return;}
                if (confirm(`Delete profile "${originalName}"? This cannot be undone.`)) {
                    const nameToDelete = originalName;
                    delete profiles[nameToDelete];
                    let profileSwitchedOrRefreshed = false;
                    if (currentProfile === nameToDelete) {
                        currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default"; // Switch to the first alphabetical
                        localStorage.setItem('currentProfile', currentProfile);
                        profileSwitchedOrRefreshed = true;
                    }
                    if(Object.keys(profiles).length === 0) { // Should technically not happen with the check above, but as a fallback
                        profiles["Default"] = []; currentProfile = "Default";
                        localStorage.setItem("currentProfile", currentProfile);
                        profileSwitchedOrRefreshed = true;
                    }
                    localStorage.setItem("profiles", JSON.stringify(profiles));
                    populateProfileModal(); loadProfileOptions();
                    if (profileSwitchedOrRefreshed) {
                        exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);
                        renderExercises();
                    }
                }
            };
        });
        document.getElementById('new-profile-name-input').value = '';
    }

    document.getElementById('add-profile-btn').onclick = function() {
        const newProfileNameInput = document.getElementById('new-profile-name-input');
        let newName = newProfileNameInput.value.trim();
        if (!newName) { alert("Please enter a profile name."); return; }
        if (Object.keys(profiles).map(p=>p.toLowerCase()).includes(newName.toLowerCase())) {
            alert(`Profile "${newName}" already exists (case-insensitive).`); return;
        }
        profiles[newName] = []; currentProfile = newName;
        localStorage.setItem("currentProfile", currentProfile);
        localStorage.setItem("profiles", JSON.stringify(profiles));
        exercises = []; loadProfileOptions(); populateProfileModal(); renderExercises();
        newProfileNameInput.value = '';
        alert(`Profile "${newName}" added and selected.`);
    };
    document.getElementById('profile-modal-overlay').onclick = closeProfileModal;

    document.addEventListener('DOMContentLoaded', () => {
        loadProfiles(); loadProfileOptions();
        loadCategoryOrder(); // Load the universal category order
        exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);
        isWeekly = localStorage.getItem('isWeeklyView') === 'true'; // Load view mode preference
        renderExercises(); // Render using the loaded category order
        populateExerciseCategoryDropdown(); // Populate dropdown using the loaded order
    });

    // Save view mode preference when toggled
    const originalToggleViewMode = toggleViewMode;
    toggleViewMode = () => {
        originalToggleViewMode();
        localStorage.setItem('isWeeklyView', isWeekly);
    };

    // Initial migration check for old customCategories storage (will run on first load after update)
    if (localStorage.getItem('customCategories') !== null && localStorage.getItem('categoryOrder') === null) {
         console.log("Migrating old customCategories to new categoryOrder...");
         loadCategoryOrder(); // This function handles the migration logic
         // The new categoryOrder will be saved by loadCategoryOrder
         // Old customCategories will be removed by loadCategoryOrder
    } else {
         // If no migration needed or already done, just load the order
         loadCategoryOrder();
    }


  </script>
</body>
</html>
