<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Training Arc: GtG Loop Tracker</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; object-src 'none';">
  <style>
  /* Reset and base */
  *, *::before, *::after { box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 650px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f8f8f8;
    color: #333;
    overflow-x: hidden;
  }
  input[type="checkbox"] {
    accent-color: #00BFFF;
    width: 18px;
    height: 18px;
    cursor: pointer;
  }

  /* Header and menu */
  .header-container {
    display: grid;
    grid-template-columns: 30px 1fr 30px; /* Left-spacer | Logo | Menu-container */
    align-items: center;
    width: 100%;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
    margin-bottom: 25px;
    height: 45px; /* Explicit height for better vertical centering of menu */
  }
  .header-container > div:first-child { /* Left spacer */
    grid-column: 1;
  }
  .logo-container {
    grid-column: 2;
    text-align: center;
    font-weight: 600;
    font-size: 1.5rem;
    color: #222;
  }
  .menu-container {
    grid-column: 3;
    justify-self: end;
    position: relative; /* For dropdown menu */
    display: flex;
    align-items: center;
    height: 100%; /* Ensure it fills grid cell height for menu centering */
  }
  .menu-icon { /* Kebab menu icon itself */
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 20px; /* Intrinsic size */
    width: 24px;  /* Intrinsic size */
    padding: 2px;
    font-weight: normal; /* Ensure not bold */
  }
  .menu-icon .dot {
    width: 5px;
    height: 5px;
    background-color: #555;
    border-radius: 50%;
  }

  /* Unified menu & modal item style */
  #dropdown-menu, .modal {
    background-color: #ffffff;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  #dropdown-menu {
    position: absolute;
    top: 30px; /* Adjusted based on menu icon position */
    right: 0;
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
    transform-origin: top right;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    z-index: 1000;
    pointer-events: none;
    min-width: 200px;
  }
  #dropdown-menu.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
  }
  .dropdown-item, .modal-item { /* Removed .cat-item */
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    font-size: 0.95rem;
    user-select: none;
    background-color: #fff;
    color: #333;
    transition: background-color 0.15s ease;
  }
   .modal-item { /* Specific for profile/category list items */
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .dropdown-item:last-child, .modal-item:last-child { /* Removed .cat-item */
    border-bottom: none;
  }
  .dropdown-item:hover, .modal-item:hover, .preset-item:hover:not(:disabled) { /* Removed .cat-item */
    background-color: #f0f0f0;
  }

  /* Progress & Headline */
  #progress-container {
    margin-bottom: 20px;
  }
  #progress-bar {
    height: 12px;
    width: 100%;
    background-color: #e9ecef;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.075);
  }
  #progress-fill {
    height: 100%;
    width: 0;
    background: linear-gradient(to right, cyan, magenta, yellow);
    transition: width 0.4s ease-in-out;
    border-radius: 6px;
  }
  #progress-label {
    text-align: right;
    font-size: 0.9rem;
    margin-top: 6px;
    color: #555;
  }
  .view-headline {
    font-size: 1.3rem;
    margin: 15px 0 20px; /* Original spacing from content */
    text-align: center;
    color: #333;
    font-weight: 500;
  }

  /* Profile Selector Styling */
  #profile-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 5px 0 15px;
  }
  #profile-select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: transparent;
    border: none;
    padding: 5px 8px;
    font-size: 1.1rem;
    font-weight: normal;
    cursor: pointer;
    outline: none;
    margin: 0;
    text-align: center;
    text-align-last: center;
    text-decoration: underline;
    color: #555;
  }
  #profile-select::-ms-expand {
    display: none;
  }


  /* Sections and rows */
  .section-header {
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #e9ecef;
    padding: 10px 15px;
    border-radius: 6px;
    margin-top: 15px;
    transition: background-color 0.2s ease;
  }
  .section-header:hover {
    background-color: #dce2e8;
  }
  .section-header h2 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 500;
    color: #333;
  }
  .section-header span { /* For + / - icons */
    font-size: 0.85rem;
    font-weight: bold;
    color: #777;
    display: inline-block;
    min-width: 1.5em;
    text-align: center;
    line-height: 1;
  }
  .section-content {
    margin-top: 10px;
    padding-left: 5px;
  }
  .exercise-row {
    display: flex;
    flex-direction: column;
    background-color: #fff;
    padding: 12px 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.07);
    border: 1px solid #e7e7e7;
    transition: box-shadow 0.2s ease;
  }
  .exercise-row:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  .exercise-row .header-row {
    display: flex;
    justify-content: space-between; /* Keeps name and edit button apart */
    align-items: center;
    margin-bottom: 6px;
  }
  .exercise-row .name {
    font-size: 1.05rem;
    font-weight: 500;
    color: #222;
    flex-grow: 1; /* Allow name to take available space */
    margin-right: 10px; /* Space between name and controls */
  }

  .reps-duration { /* This class now styles the combined weight/reps/duration/timer line */
    color: #777;
    font-size: 0.9rem;
    margin-top: 4px;
    margin-bottom: 8px;
    display: flex; /* Use flexbox to align items */
    align-items: center; /* Vertically center */
    gap: 10px; /* Space between details and timer elements */
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
  }

    /* Timer specific styles (Modified) */
    .timer-control {
        /* Remove padding, border, background for icon appearance */
        padding: 0;
        border: none;
        background-color: transparent;
        border-radius: 0; /* Remove border-radius */

        font-size: 0.85rem; /* Still keeps text size small for 'Stop' */
        cursor: pointer;
        transition: opacity 0.2s ease; /* Transition opacity */
        line-height: 1; /* Compact */
        flex-shrink: 0; /* Prevent shrinking */
        display: flex; /* Use flex for centering icon */
        align-items: center; /* Vertically center icon */
        justify-content: center; /* Horizontally center icon */
        min-width: 30px; /* Give icon button a minimum size */
        min-height: 30px; /* Give icon button a minimum size */
        color: #555; /* Default icon color */
    }
    .timer-control svg {
        fill: currentColor; /* Use button text color for icon */
    }
    .timer-control:hover {
        opacity: 0.7; /* Hover effect: less opaque */
    }
     .timer-control:disabled {
         color: #cccccc; /* Grey color for disabled icon */
         cursor: not-allowed;
         opacity: 1; /* Disabled items are usually not semi-transparent */
     }

    .timer-control.start-grey {
        color: #6c757d; /* Grey color for Start icon */
    }
     .timer-control.start-grey:hover:not(:disabled) {
        color: #5a6268; /* Darker grey on hover */
    }


    .timer-control.stop {
        color: magenta; /* Magenta color for Stop text */
        /* No icon for stop, just text */
        padding: 4px 8px; /* Re-add a bit of padding for text button */
         min-width: auto; /* Allow text button to size naturally */
    }
     .timer-control.stop:hover:not(:disabled) {
        color: #cc0099; /* Darker magenta on hover */
    }


    .timer-display {
        font-size: 0.9rem;
        font-weight: bold;
        /* Updated color to match Add Exercise button */
        color: #00BFFF;
        min-width: 50px; /* Give it some minimal width */
        text-align: right; /* Align text to the right */
        flex-shrink: 0; /* Prevent display from shrinking */
        margin-left: auto; /* Push display to the right if it's the first timer element */
        display: none; /* Initially hidden */
    }
     .timer-display.active { /* Show when timer is active */
        display: inline-block;
     }
     .timer-display.finished {
         color: #28a745; /* Green when finished */
         font-weight: normal; /* Normal weight for 'Done!' */
         font-style: italic;
         min-width: auto; /* Allow 'Done!' to be smaller */
     }

    /* Container for timer display and button to control their layout together */
    .timer-container {
        display: flex;
        align-items: center;
        gap: 8px; /* Space between display and button */
        margin-left: auto; /* Push the entire container to the right */
        flex-shrink: 0; /* Prevent container from shrinking */
        min-width: 80px; /* Ensure container has space */
         justify-content: flex-end; /* Align contents to the right */
    }


  .weekday-row {
    display: flex;
    align-items: center;
    margin-top: 6px;
    padding: 4px 0;
  }
  .weekday-label {
    color: #444;
    font-size: 0.9rem;
    width: 70px;
    font-weight: 500;
  }
  .checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-left: 8px;
  }
  .checkbox-container {
    display: flex;
    align-items: center;
  }
  /* Edit Button Styling (Modified for icon) */
  .edit-button {
    color: #777; /* Icon color */
    font-size: 0; /* Hide potential text fallback */
    background-color: transparent;
    border: none;
    cursor: pointer;
    padding: 4px; /* Adjust padding for icon */
    border-radius: 4px;
    transition: color 0.2s ease, background-color 0.2s ease;
    display: flex; /* For centering SVG */
    align-items: center;
    justify-content: center;
    min-width: 28px; /* Ensure button is clickable */
    min-height: 28px; /* Ensure button is clickable */
  }
   .edit-button svg {
       fill: currentColor; /* Use button color for SVG */
       width: 18px;
       height: 18px;
   }
  .edit-button:hover {
    background-color: #e6f2ff;
    color: #007bff;
  }

  /* Buttons */
  .app-button {
    padding: 12px 18px;
    font-size: 1rem;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    width: 100%;
    margin-top: 15px;
    transition: opacity 0.2s ease, transform 0.1s ease;
    text-align: center;
  }
  .app-button:hover {
    opacity: 0.85;
  }
  .app-button:active {
    transform: translateY(1px);
  }

  .add-button {
    background-color: #00BFFF;
    color: #FFFFFF;
  }
  .reset-button {
    background-color: magenta;
    color: #fff;
  }

  /* Modal specifics */
  .modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background-color: rgba(0,0,0,0.5);
    z-index: 998; display: none;
  }
  .modal-overlay.active { display: block; }
  .modal {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    padding: 20px 25px;
    z-index: 999; width: 90%; max-width: 450px;
    max-height: 90vh; overflow-y: auto; display: none;
    opacity: 0; transition: opacity 0.25s ease-out, transform 0.25s ease-out;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
  }
  .modal.active {
    display: block; opacity: 1; transform: translate(-50%, -50%) scale(1);
  }
  .modal h3 {
    margin-top: 0; margin-bottom: 20px;
    font-size: 1.4rem; color: #333;
    text-align: center; font-weight: 500;
  }
  .modal-label {
    display: block; margin-bottom: 6px; font-size: 0.9rem;
    color: #444; font-weight: 500;
  }
  .modal-input, .modal-number, .modal-select {
    width: 100%; padding: 10px 12px; margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1rem; height: auto;
    background-color: #fff;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  /* Input field used for renaming in lists */
  .list-rename-input {
    margin-bottom: 0 !important; /* Override .modal-input margin */
    flex-grow: 1;
  }

  .modal-input:focus, .modal-number:focus, .modal-select:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
    outline: none;
  }
  #ex-cat { /* Select for exercise category */
    appearance: none;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3csvg%3e");
    background-repeat: no-repeat; background-position: right .75rem center; background-size: 16px 12px;
  }

  .modal-actions {
    display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;
  }
  .modal-button {
    padding: 10px 18px; font-size: 0.95rem; font-weight: 500;
    border: none; border-radius: 6px; cursor: pointer;
    transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
  }
   .modal-button:active { transform: translateY(1px); }
  .modal-button.save { background-color: #00BFFF; color: #fff; }
  .modal-button.cancel { background-color: #6c757d; color: #fff; }

  .modal-button.delete {
    background-color: magenta;
    color: #fff;
    padding: 8px 12px;
    font-size: 1.1rem;
    font-weight: bold;
    line-height: 1;
    min-width: auto;
    margin-right: auto; /* For main modal delete button like exercise delete */
  }
  /* Smaller buttons inside lists (profile/category rename/delete) */
  .modal-item .modal-button {
    padding: 6px 10px;
    font-size: 0.85rem;
  }
  .modal-item .modal-button.delete { /* 'x' delete button in lists */
     margin-right: 0;
     padding: 6px 10px;
     font-size: 1rem;
  }

  .modal-button.delete:hover, .modal-button.save:hover, .modal-button.cancel:hover {
    opacity: 0.85;
  }

  #add-profile-btn, #add-cat-btn { /* Specific Add buttons in modals */
    background-color: #00BFFF;
    color: #FFFFFF;
  }

  /* --- DRAG & DROP & CATEGORY MANAGEMENT START --- */
  #cat-list, #profile-list { /* Removed #preset-list */
    margin-top: 10px; margin-bottom: 20px;
  }

  #cat-list .modal-item {
      cursor: grab; /* Indicate draggable item */
      position: relative; /* Needed for drag-over effect */
      z-index: 1; /* Ensure items are above potential drag indicators */
  }

  #cat-list .modal-item.dragging {
      opacity: 0.5; /* Make the item being dragged semi-transparent */
  }

  #cat-list .modal-item.drag-over-before {
      border-top: 2px dashed #007bff; /* Visual cue for drop target */
  }

   #cat-list .modal-item.drag-over-after {
      border-bottom: 2px dashed #007bff; /* Visual cue for drop target */
  }
  /* --- DRAG & DROP & CATEGORY MANAGEMENT END --- */


  #schedule-inputs {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px; margin-top: 10px; margin-bottom: 15px;
  }
  #schedule-inputs .modal-label { margin-bottom: 4px; font-size: 0.85rem; }
  #schedule-inputs .modal-number { margin-bottom: 0; text-align: center; }

  /* Custom style for grey zero */
  .modal-number.grey-zero {
    color: #aaa; /* Light grey color */
  }
  .modal-number:focus.grey-zero {
    color: #333; /* Change back to normal text color on focus */
  }

  /* Style for reps/duration input group */
  .reps-duration-input-group {
    display: flex;
    align-items: center; /* Vertically center items in the flex container */
    gap: 10px; /* Space between inputs and 'or' */
    margin-bottom: 15px;
  }
   .reps-duration-input-group > span {
       align-self: center; /* Explicitly center the 'or' text itself */
       font-size: 0.9rem;
       color: #555;
       flex-shrink: 0; /* Prevent 'or' from shrinking */
       padding-top: 18px; /* Add padding to align 'or' with the bottom of labels */
   }
  .reps-duration-input-group .input-container {
      flex-grow: 1; /* Allow inputs to grow */
  }
  .reps-duration-input-group .input-container label {
      display: block; /* Ensure label is above input */
      margin-bottom: 4px; /* Space between label and input */
      font-size: 0.85rem; /* Smaller label font */
      color: #444;
      font-weight: 500;
  }

    /* Confetti Styles */
    .confetti {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* Allow clicking through confetti */
        overflow: hidden; /* Hide particles outside viewport */
        z-index: 2000; /* Ensure confetti is on top */
    }

    .confetti-particle {
        position: absolute;
        width: 8px;
        height: 8px;
        /* Colors set dynamically */
        animation: fall 2s ease-out forwards; /* Duration and timing function */
         opacity: 1; /* Start visible */
    }

    @keyframes fall {
        0% {
            transform: translate(0, 0) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translate(var(--fall-x, 0), var(--fall-y, 100vh)) rotate(var(--rotate, 720deg));
            opacity: 0;
        }
    }


</style>
</head>
<body>
  <div class="header-container">
    <div></div> <div class="logo-container">Training Arc</div>
    <div class="menu-container">
      <div class="menu-icon" onclick="toggleMenu()">
        <div class="dot"></div><div class="dot"></div><div class="dot"></div>
      </div>
      <div id="dropdown-menu">
        <div class="dropdown-item" onclick="toggleViewMode()">Toggle View Mode</div>
        <div class="dropdown-item" onclick="openProfileModal()">Manage Profiles</div>
        <div class="dropdown-item" onclick="openCatModal()">Manage Categories</div>
        <div class="dropdown-item" onclick="exportExercises()">Export Exercises</div>
        <div class="dropdown-item" onclick="importExercises()">Import Exercises</div>
        <div class="dropdown-item" onclick="clearExercises()">Clear All Exercises</div>
        <div class="dropdown-item" onclick="showAbout()">About</div>
      </div>
    </div>
  </div>

  <div id="progress-container">
    <div id="progress-bar"><div id="progress-fill"></div></div>
    <div id="progress-label">0%</div>
  </div>

  <div id="view-headline" class="view-headline"></div>

  <div id="profile-container">
    <select id="profile-select" onchange="switchProfile()"></select>
  </div>

  <div id="tracker-content"></div>

  <button class="app-button add-button" id="add-exercise-btn">Add New Exercise</button>
  <button class="app-button reset-button" id="reset-btn">Reset Weekly Progress</button>

  <div class="modal-overlay" id="modal-overlay"></div>
  <div class="modal" id="modal">
    <h3 id="modal-title-ex">Add/Edit Exercise</h3>
    <label class="modal-label" for="ex-name">Exercise Name</label>
    <input class="modal-input" type="text" id="ex-name" placeholder="e.g., Push-ups" />
    <label class="modal-label" for="ex-cat">Category</label>
    <select class="modal-input modal-select" id="ex-cat"></select>

    <label class="modal-label" for="ex-weight-num">Weight</label>
    <input class="modal-number modal-input" type="number" min="0" id="ex-weight-num" placeholder="e.g., 50" />


    <div class="reps-duration-input-group">
        <div class="input-container">
            <label for="ex-reps-num">Reps</label> <input class="modal-number modal-input" type="number" min="0" id="ex-reps-num" placeholder="e.g., 10" />
        </div>
        <span>or</span>
        <div class="input-container">
             <label for="ex-duration-text">Duration</label> <input class="modal-input" type="text" id="ex-duration-text" placeholder="e.g., 30s, 1m 30s, Max hold" /> </div>
    </div>


    <label class="modal-label">Sets per Weekday</label>
    <div id="schedule-inputs"></div>
    <div class="modal-actions">
      <button class="modal-button delete" id="delete-btn" style="display:none;">x</button> <button class="modal-button cancel" onclick="closeModal()">Cancel</button>
      <button class="modal-button save" id="save-btn">Save</button>
    </div>
  </div>

  <div class="modal-overlay" id="profile-modal-overlay"></div>
  <div class="modal" id="profile-modal">
    <h3>Manage Profiles</h3>
    <div id="profile-list"></div>
    <input type="text" id="new-profile-name-input" class="modal-input" placeholder="New profile name" style="margin-top: 15px; margin-bottom:10px;">
    <button class="modal-button save" id="add-profile-btn" style="width:100%; margin-bottom:10px;">Add Profile</button>
    <div class="modal-actions" style="justify-content: flex-end;">
        <button class="modal-button cancel" onclick="closeProfileModal()">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="cat-modal-overlay"></div>
  <div class="modal" id="cat-modal">
    <h3>Manage Categories</h3>
    <label class="modal-label">Drag to reorder. Click 'x' to remove (not possible for original presets).</label> <div id="cat-list"></div> <input type="text" id="new-category-name-input" class="modal-input" placeholder="Add new category..." style="margin-top: 15px; margin-bottom:10px;">
    <button class="modal-button save" id="add-cat-btn" style="width:100%; margin-bottom:10px;">Add Category</button> <div class="modal-actions" style="justify-content: flex-end;">
      <button class="modal-button cancel" onclick="closeCatModal()">Close</button>
      </div>
  </div>

<script>
    const WEEKDAYS=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
    const ORIGINAL_PRESET_CATEGORIES=["Daily GTG","Upper Body","Lower Body","Mobility","Core","Conditioning","Skills"]; // Keep original presets separate
    let exercises=[], collapsedCategories={};
    let isWeekly=true;
    let editIndex=null;
    let previousProgressPercentage = 0; // To track progress for confetti

    // Timer variables
    // { intervalId: number, exerciseIndex: number, exerciseElement: HTMLElement, initialSeconds: number, remainingSeconds: number, displayElement: HTMLElement, timerButton: HTMLElement }
    let activeTimer = null;

    // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
    let categoryOrder = []; // This will hold the current order of ALL categories
    let dragStartIndex = -1; // For drag and drop

    function loadCategoryOrder() {
        try {
            const storedOrder = localStorage.getItem('categoryOrder');
            if (storedOrder) {
                 categoryOrder = JSON.parse(storedOrder);
                 // Migration or cleanup: ensure categoryOrder only contains strings and no duplicates
                 categoryOrder = Array.from(new Set(categoryOrder.filter(item => typeof item === 'string')));

                 // Ensure all original presets are included if they somehow got removed, append them to the end
                 const currentOrderLower = categoryOrder.map(cat => cat.toLowerCase());
                 ORIGINAL_PRESET_CATEGORIES.forEach(preset => {
                     if (!currentOrderLower.includes(preset.toLowerCase())) {
                         categoryOrder.push(preset);
                     }
                 });

            } else {
                // Initial load: Create order from old customCategories (if any) and presets
                const oldCustomCategories = JSON.parse(localStorage.getItem('customCategories')) || [];
                 // Start with old custom categories, then add presets not already in custom
                categoryOrder = [...oldCustomCategories, ...ORIGINAL_PRESET_CATEGORIES.filter(p => !oldCustomCategories.map(c => c.toLowerCase()).includes(p.toLowerCase()))];
                 // Remove old customCategories from storage after migration
                 localStorage.removeItem('customCategories');
            }
        } catch(e) {
            console.error("Error loading category order:", e);
            categoryOrder = [...ORIGINAL_PRESET_CATEGORIES]; // Fallback to just presets
        }
         saveCategoryOrderToStorage(); // Save the potentially new or corrected order immediately
         console.log("Loaded/Initial Category Order:", categoryOrder); // Log for debugging
    }

     function saveCategoryOrderToStorage() {
        localStorage.setItem('categoryOrder', JSON.stringify(categoryOrder));
         console.log("Saved Category Order:", categoryOrder); // Log for debugging
    }

    // This function now just returns the loaded/saved order
    function allCategories(){ return [...categoryOrder]; } // Return a copy
    // --- DRAG & DROP & CATEGORY MANAGEMENT END ---

    function toggleMenu(){ document.getElementById('dropdown-menu').classList.toggle('show'); }
    function toggleViewMode(){ isWeekly=!isWeekly; localStorage.setItem('isWeeklyView', isWeekly); document.getElementById('dropdown-menu').classList.remove('show'); renderExercises(); } // Save view mode here

    function exportExercises(){
        toggleMenu();
        if (exercises.length === 0 && categoryOrder.length === 0) { // Check categoryOrder too
            alert("No exercises or categories to export for the current profile.");
            return;
        }
        const profileName = currentProfile; // Use the actual profile name from the app

        // --- Code to truncate and sanitize profile name for filename ---
        const MAX_FILENAME_PROFILE_LENGTH = 40; // Keep the max length limit
        let truncatedProfileName = profileName.length > MAX_FILENAME_PROFILE_LENGTH
            ? profileName.substring(0, MAX_FILENAME_PROFILE_LENGTH)
            : profileName;

        // Sanitize the profile name for filename compatibility (remove spaces, remove illegal chars)
        // Removing spaces to meet the 'no space in between' requirement for the entire filename
        const sanitizedProfileName = truncatedProfileName.replace(/[\s]/g, '').replace(/[^a-zA-Z0-9_\-.]/g, '');
        // --- End truncation and sanitization code ---

        const exportData = {
            profileName: currentProfile, // Keep the original, full name inside the file data
            exercises: exercises,
            categoryOrder: categoryOrder, // Export the category order
            viewSettings: {
                 isWeekly: isWeekly,
                 // Also export the collapsed state for the current profile
                 collapsedCategories: JSON.parse(localStorage.getItem('collapsedCategories_' + currentProfile)) || {}
            }
        };

        const a=document.createElement('a');
        a.href='data:text/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(exportData));

        // --- Modified Filename Format: ProfilenameYYMMDD.json ---
        const now = new Date();
        const year = now.getFullYear().toString().slice(-2); // Get last 2 digits of year
        const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Get month (0-11) and pad
        const day = now.getDate().toString().padStart(2, '0'); // Get day and pad
        const yymmdd = `${year}${month}${day}`; // Combine into YYMMDD

        a.download= `${sanitizedProfileName}${yymmdd}.json`; // Combine sanitized name and YYMMDD directly
        // --- End Modified Filename Format ---

        a.click();
    }

    function importExercises(){
        toggleMenu();
        // Stop any active timer before potentially changing exercises data
        stopTimer();

        const inp=document.createElement('input');
        inp.type='file';
        inp.accept='application/json';
        inp.onchange=e=>{
            const f=e.target.files[0];
            if(!f)return;
            const r=new FileReader();
            r.onload=()=>{
                try {
                    const importedData = JSON.parse(r.result);
                    if (importedData && importedData.exercises && Array.isArray(importedData.exercises)) {
                        let importToProfile = currentProfile;
                        let newProfileCreated = false;
                        let profileSwitchConfirmed = false;

                        if (importedData.profileName) {
                            if (!profiles[importedData.profileName]) {
                                if (confirm(`Imported data is for profile "${importedData.profileName}". Create this profile and import data into it?`)) {
                                    profiles[importedData.profileName] = [];
                                    importToProfile = importedData.profileName;
                                    newProfileCreated = true;
                                    profileSwitchConfirmed = true;
                                } else if (confirm(`Import into current profile "${currentProfile}" instead? This will overwrite existing data for "${currentProfile}".`)){
                                    profileSwitchConfirmed = true;
                                } else { return; }
                            } else if (importedData.profileName !== currentProfile) {
                                if (confirm(`Imported data is for profile "${importedData.profileName}". Switch to this profile and overwrite its data?`)) {
                                    importToProfile = importedData.profileName;
                                    profileSwitchConfirmed = true;
                                } else if (confirm(`Import into current profile "${currentProfile}" instead? This will overwrite existing data for "${currentProfile}".`)) {
                                    profileSwitchConfirmed = true;
                                } else { return; }
                            } else {
                                if (!confirm(`This will overwrite all exercises in the current profile "${currentProfile}". Continue?`)) { return; }
                                profileSwitchConfirmed = true;
                            }
                        } else {
                             if (!confirm(`No profile name in import file. Import exercises into current profile "${currentProfile}"? This will overwrite existing data.`)) { return; }
                            profileSwitchConfirmed = true;
                        }

                        if (!profileSwitchConfirmed) return;

                        // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
                        // Handle imported category order
                        if (importedData.categoryOrder && Array.isArray(importedData.categoryOrder)) {
                             if (confirm(`Imported data includes a custom category order. Use this order and merge in any new categories?`)) {
                                 const importedOrder = importedData.categoryOrder.filter(item => typeof item === 'string');
                                 const currentOrderLower = categoryOrder.map(c => c.toLowerCase());

                                 // Add imported categories that are not currently present
                                 importedOrder.forEach(importedCat => {
                                     if (!currentOrderLower.includes(importedCat.toLowerCase())) {
                                         categoryOrder.push(importedCat); // Add new ones to the end initially
                                     }
                                 });

                                 // Now reorder categoryOrder based on the importedOrder sequence
                                 const newCategoryOrder = importedOrder.filter(cat => categoryOrder.map(c => c.toLowerCase()).includes(cat.toLowerCase())); // Start with existing categories from import
                                  // Add any existing categories not in the import to the end
                                  categoryOrder.forEach(currentCat => {
                                      if (!newCategoryOrder.map(c => c.toLowerCase()).includes(currentCat.toLowerCase())) {
                                          newCategoryOrder.push(currentCat);
                                      }
                                  });
                                 categoryOrder = newCategoryOrder; // Apply the merged and reordered list

                                 saveCategoryOrderToStorage(); // Save the merged/reordered categories
                                 populateCatModal(); // Refresh modal if open
                                 populateExerciseCategoryDropdown(); // Update dropdown
                             } else {
                                  // User chose not to use imported order, keep current categoryOrder state
                                  // Still need to ensure imported exercises' categories exist in categoryOrder
                                   importedData.exercises.forEach(ex => {
                                       if (ex.category) {
                                           const catExists = categoryOrder.some(c => c.toLowerCase() === ex.category.toLowerCase());
                                           if (!catExists) {
                                                if (confirm(`The exercise "${ex.name}" uses category "${ex.category}" which is not in your list. Add "${ex.category}"?`)) {
                                                     categoryOrder.push(ex.category); // Add new exercise category to the end
                                                     saveCategoryOrderToStorage();
                                                     populateCatModal();
                                                     populateExerciseCategoryDropdown();
                                                }
                                           }
                                       }
                                   });
                             }
                        } else {
                             // No categoryOrder in import, just ensure exercise categories exist
                             importedData.exercises.forEach(ex => {
                                if (ex.category) {
                                    const catExists = categoryOrder.some(c => c.toLowerCase() === ex.category.toLowerCase());
                                    if (!catExists) {
                                         if (confirm(`The exercise "${ex.name}" uses category "${ex.category}" which is not in your list. Add "${ex.category}"?`)) {
                                             categoryOrder.push(ex.category); // Add new exercise category to the end
                                             saveCategoryOrderToStorage();
                                             populateCatModal();
                                             populateExerciseCategoryDropdown();
                                         }
                                    }
                                }
                             });
                        }
                        // --- DRAG & DROP & CATEGORY MANAGEMENT END ---


                        currentProfile = importToProfile;
                        localStorage.setItem("currentProfile", currentProfile);
                        exercises = importedData.exercises.map(ensureScheduleFormat);
                        profiles[currentProfile] = exercises;
                        localStorage.setItem("profiles", JSON.stringify(profiles));

                        if (newProfileCreated || importedData.profileName !== document.getElementById("profile-select").value) {
                            loadProfileOptions();
                        }
                        document.getElementById('profile-select').value = currentProfile;

                        if (importedData.viewSettings && typeof importedData.viewSettings.isWeekly === 'boolean') {
                            isWeekly = importedData.viewSettings.isWeekly;
                             localStorage.setItem('isWeeklyView', isWeekly); // Save imported view mode
                        }
                         // Restore collapsed state from imported data if available, save to profile-specific key
                         if (importedData.viewSettings && importedData.viewSettings.collapsedCategories) {
                              collapsedCategories = importedData.viewSettings.collapsedCategories;
                              localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                         } else {
                              // If imported data doesn't have collapsed state, load current profile's state
                              try {
                                  collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories_' + currentProfile)) || {};
                              } catch (e) {
                                   console.error("Error loading collapsed state during import fallback for profile", currentProfile, e);
                                   collapsedCategories = {}; // Fallback to empty
                              }
                         }

                        renderExercises();
                        // populateExerciseCategoryDropdown(); // Called during category import handling
                        alert("Data imported successfully to profile: " + currentProfile + "!");
                    } else { alert("Invalid file format. Expected 'exercises' array."); }
                } catch (err) { alert("Error importing file: " + err.message); console.error("Import error:", err); }
            };
            r.readAsText(f);
        };
        inp.click();
    }

    function clearExercises(){
        toggleMenu();
         // Stop any active timer before potentially changing exercises data
        stopTimer();

        if (exercises.length === 0) { alert("No exercises to clear."); return; }
        if(confirm(`Are you sure you want to clear all exercises for the current profile "${currentProfile}"? This cannot be undone.`)){
            exercises.forEach(e=>e.progress={});
            saveExercises(); renderExercises();
        }
    }
    function openCatModal(){
        document.getElementById('dropdown-menu').classList.remove('show');
        document.getElementById('cat-modal-overlay').classList.add('active');
        document.getElementById('cat-modal').classList.add('active');
        populateCatModal();
    }
    function closeCatModal(){
        document.getElementById('cat-modal-overlay').classList.remove('active');
        document.getElementById('cat-modal').classList.remove('active');
        populateExerciseCategoryDropdown(); // Refresh dropdown in case categories changed
        renderExercises(); // Refresh main view in case order changed
    }
    function showAbout(){
        toggleMenu();
        alert('Training Arc - GtG Loop Tracker\n\nBeta Version 1.4 (Improved Timer)\nA loop tracker for daily habits.\nProgress and profiles are saved locally.\n\nby Sascha Leng');
    }

    // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
    function populateCatModal() {
        const list = document.getElementById('cat-list');
        list.innerHTML = '';

        if (categoryOrder.length === 0) {
             list.innerHTML = `<p style="text-align:center; color:#777; margin-top:10px;">No categories defined. Add one below!</p>`;
             return;
        }

        categoryOrder.forEach((catName) => { // Iterate directly over the order array
            const originalCategoryName = catName; // For closure

            const item = document.createElement('div');
            item.className = 'modal-item';
            item.setAttribute('draggable', true); // Make the item draggable
            item.setAttribute('data-name', originalCategoryName); // Store the category name for drag/drop

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalCategoryName;
            nameSpan.style.flexGrow = "1";

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'modal-input list-rename-input';
            nameInput.value = originalCategoryName;
            nameInput.style.display = 'none';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.className = 'modal-button';

            const saveRenameBtn = document.createElement('button');
            saveRenameBtn.textContent = 'Save';
            saveRenameBtn.className = 'modal-button save';
            saveRenameBtn.style.display = 'none';

            const cancelRenameBtn = document.createElement('button');
            cancelRenameBtn.textContent = 'Cancel';
            cancelRenameBtn.className = 'modal-button cancel';
            cancelRenameBtn.style.display = 'none';

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'x';
            deleteBtn.className = 'modal-button delete';
            // Disable delete for original preset categories
            deleteBtn.disabled = ORIGINAL_PRESET_CATEGORIES.map(p => p.toLowerCase()).includes(originalCategoryName.toLowerCase());


            const controlsDiv = document.createElement('div');
            controlsDiv.style.display = 'flex';
            controlsDiv.style.alignItems = 'center';
            controlsDiv.style.gap = '8px';
            controlsDiv.appendChild(renameBtn);
            controlsDiv.appendChild(saveRenameBtn);
            controlsDiv.appendChild(cancelRenameBtn);
            controlsDiv.appendChild(deleteBtn);

            item.appendChild(nameSpan);
            item.appendChild(nameInput);
            item.appendChild(controlsDiv);
            list.appendChild(item);

            nameInput.onfocus = () => { item.setAttribute('draggable', false); };
            nameInput.onblur = () => { item.setAttribute('draggable', true); };


            renameBtn.onclick = () => {
                 // Disable dragging while editing
                 item.setAttribute('draggable', false);
                nameSpan.style.display = 'none';
                nameInput.style.display = 'block'; nameInput.style.flexGrow = '1';
                nameInput.value = nameSpan.textContent; nameInput.focus();
                renameBtn.style.display = 'none';
                saveRenameBtn.style.display = 'inline-block';
                cancelRenameBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            };

            cancelRenameBtn.onclick = () => {
                 // Re-enable dragging
                 item.setAttribute('draggable', true);
                nameSpan.style.display = 'block';
                nameInput.style.display = 'none';
                renameBtn.style.display = 'inline-block';
                saveRenameBtn.style.display = 'none';
                cancelRenameBtn.style.display = 'none';
                deleteBtn.style.display = 'inline-block';
            };

            saveRenameBtn.onclick = () => {
                const newNameTrimmed = nameInput.value.trim();
                if (!newNameTrimmed) {
                    alert("Category name cannot be empty."); nameInput.focus(); return;
                }
                const newNameLower = newNameTrimmed.toLowerCase();
                const originalNameLower = originalCategoryName.toLowerCase();

                if (newNameLower === originalNameLower && newNameTrimmed === originalCategoryName) {
                    cancelRenameBtn.onclick(); return; // No change
                }

                 // Check for conflicts in the *entire* categoryOrder list
                const conflict = categoryOrder.some(cat => cat.toLowerCase() === newNameLower && cat.toLowerCase() !== originalNameLower);

                if (conflict) {
                    alert(`Category name "${newNameTrimmed}" already exists.`);
                    nameInput.focus(); return;
                }

                // Update exercises using the old category name
                exercises.forEach(ex => {
                    if (ex.category === originalCategoryName) {
                        ex.category = newNameTrimmed;
                    }
                });
                saveExercises(); // Save exercises with updated category names

                // Update the categoryOrder array by finding the old name and replacing it
                const oldIndex = categoryOrder.indexOf(originalCategoryName);
                if(oldIndex !== -1) {
                    categoryOrder[oldIndex] = newNameTrimmed;
                    saveCategoryOrderToStorage();
                    alert(`Category "${originalCategoryName}" renamed to "${newNameTrimmed}".`);
                    populateCatModal(); // Refresh this modal's list
                    // populateExerciseCategoryDropdown and renderExercises called when modal closes
                } else {
                     console.error("Category not found in order array during rename:", originalCategoryName);
                      cancelRenameBtn.onclick(); // Revert UI if not found in array
                }
            };

            deleteBtn.onclick = () => {
                 if (deleteBtn.disabled) {
                     alert("Original preset categories cannot be removed.");
                     return;
                 }
                 // Check if any exercises are using this category before allowing deletion
                const exercisesUsingCategory = exercises.filter(ex => ex.category === originalCategoryName);
                if (exercisesUsingCategory.length > 0) {
                     const exerciseNames = exercisesUsingCategory.map(ex => ex.name).join(', ');
                     alert(`Cannot remove category "${originalCategoryName}" because it is used by the following exercises: ${exerciseNames}. Please change their categories first.`);
                     return;
                }

                if (confirm(`Remove category "${originalCategoryName}"?`)) {
                    // Find the index by name in the current order array
                    const indexToDelete = categoryOrder.indexOf(originalCategoryName);
                    if(indexToDelete !== -1) {
                         categoryOrder.splice(indexToDelete, 1);
                         saveCategoryOrderToStorage();
                         populateCatModal(); // Refresh this modal's list
                         // populateExerciseCategoryDropdown and renderExercises called when modal closes
                    } else {
                         console.error("Category not found in order array for deletion:", originalCategoryName);
                         populateCatModal(); // Just refresh in case of discrepancy
                    }
                }
            };
        });
        document.getElementById('new-category-name-input').value = '';
    }


    document.getElementById('add-cat-btn').onclick=()=>{
        const newCatNameInput = document.getElementById('new-category-name-input');
        const newCatName = newCatNameInput.value.trim();
        if (!newCatName) {
            alert("Please enter a category name."); return;
        }
        const lowerNewCatName = newCatName.toLowerCase();
        // Check for duplicates in the entire categoryOrder list (case-insensitive check)
        if (categoryOrder.map(c=>c.toLowerCase()).includes(lowerNewCatName)) {
            alert(`Category "${newCatName}" already exists (case-insensitive).`);
        } else {
            categoryOrder.push(newCatName); // Add to the end
            saveCategoryOrderToStorage();
            populateCatModal(); // Refresh the modal list to show the new item
            // populateExerciseCategoryDropdown and renderExercises called when modal closes
            newCatNameInput.value = '';
        }
    };
    document.getElementById('cat-modal-overlay').onclick=closeCatModal;

    // Drag & Drop Event Listeners on the cat-list container
    const catListElement = document.getElementById('cat-list');

    catListElement.addEventListener('dragstart', (e) => {
        const targetItem = e.target.closest('.modal-item');
        if (!targetItem || !targetItem.draggable) return; // Only drag draggable items
        // Prevent dragging if the item is currently being renamed
         if (targetItem.querySelector('.list-rename-input').style.display !== 'none') {
             e.preventDefault();
             return;
         }


        const categoryName = targetItem.getAttribute('data-name');
        dragStartIndex = categoryOrder.indexOf(categoryName); // Get index from the actual order array

        if (dragStartIndex === -1) { // Should not happen if logic is correct
             e.preventDefault(); return;
        }

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', categoryName); // Pass the category name or index
        // Use a small timeout to allow the browser to capture the drag image before modifying classes
        setTimeout(() => {
             targetItem.classList.add('dragging');
        }, 0);
    });

    catListElement.addEventListener('dragover', (e) => {
        e.preventDefault(); // Necessary to allow dropping
        e.dataTransfer.dropEffect = 'move';

        const targetItem = e.target.closest('.modal-item');
        // Find the actual item element, not its children, and ensure it's in the list and not the item being dragged
        if (!targetItem || !catListElement.contains(targetItem) || targetItem.classList.contains('dragging')) {
             // Clear drag-over classes if not hovering over a valid target item
             catListElement.querySelectorAll('.modal-item').forEach(item => {
                 item.classList.remove('drag-over-before', 'drag-over-after');
             });
             return;
         }

        // Remove existing drag-over classes from all items
        catListElement.querySelectorAll('.modal-item').forEach(item => {
            item.classList.remove('drag-over-before', 'drag-over-after');
        });

        // Determine if dragging before or after the target item
        const targetRect = targetItem.getBoundingClientRect();
        const targetMiddleY = targetRect.top + targetRect.height / 2;

        if (e.clientY < targetMiddleY) {
            targetItem.classList.add('drag-over-before');
        } else {
             targetItem.classList.add('drag-over-after');
        }
    });

    catListElement.addEventListener('dragleave', (e) => {
         // Only remove class if leaving the list item itself, not just moving within it
         const targetItem = e.target.closest('.modal-item');
         if (targetItem && catListElement.contains(targetItem) && !targetItem.contains(e.relatedTarget)) {
             targetItem.classList.remove('drag-over-before', 'drag-over-after');
         } else if (!catListElement.contains(e.relatedTarget)) {
              // Left the entire list container
             catListElement.querySelectorAll('.modal-item').forEach(item => {
                 item.classList.remove('drag-over-before', 'drag-over-after');
             });
         }
    });


    catListElement.addEventListener('drop', (e) => {
        e.preventDefault();
        const dragItemElement = catListElement.querySelector('.modal-item.dragging'); // The DOM element being dragged
        const targetItemElement = e.target.closest('.modal-item'); // The DOM element being dropped onto

        // Remove drag-over classes from all items
        catListElement.querySelectorAll('.modal-item').forEach(item => {
            item.classList.remove('drag-over-before', 'drag-over-after');
        });

        if (!dragItemElement || !targetItemElement || !catListElement.contains(targetItemElement) || dragItemElement === targetItemElement) return;

        const draggedCategoryName = dragItemElement.getAttribute('data-name');
        const targetCategoryName = targetItemElement.getAttribute('data-name');

        const dragIndex = categoryOrder.indexOf(draggedCategoryName);
        let dropIndex = categoryOrder.indexOf(targetCategoryName);

        if (dragIndex === -1 || dropIndex === -1) { // Should not happen
             console.error("Dragged or target category not found in order array.");
             return;
        }

         // Adjust dropIndex based on whether we're dropping before or after the target
        const targetRect = targetItemElement.getBoundingClientRect();
        const targetMiddleY = targetRect.top + targetRect.height / 2;
        if (e.clientY > targetMiddleY) {
            // Dropping after the target item
            dropIndex++;
        }

        // Ensure dropIndex is not out of bounds after incrementing
         dropIndex = Math.min(dropIndex, categoryOrder.length);

         // Prevent dropping onto the item being dragged, or before itself (which is the same position)
         if (dropIndex === dragIndex || dropIndex === dragIndex + 1) {
             populateCatModal(); // Re-render to clear drag classes
             return;
         }


        // Perform the move in the categoryOrder array
        // 1. Remove the dragged item from its original position
        const [movedCategory] = categoryOrder.splice(dragIndex, 1);

        // 2. Insert the dragged item at the new position
        categoryOrder.splice(dropIndex, 0, movedCategory);

        saveCategoryOrderToStorage(); // Save the new order
        populateCatModal(); // Re-render the list to reflect the new order
        // populateExerciseCategoryDropdown() and renderExercises() called when modal closes
    });

    catListElement.addEventListener('dragend', (e) => {
        const dragItem = catListElement.querySelector('.modal-item.dragging');
        if (dragItem) {
            dragItem.classList.remove('dragging');
        }
         // Also ensure drag-over classes are removed on drag end
         catListElement.querySelectorAll('.modal-item').forEach(item => {
             item.classList.remove('drag-over-before', 'drag-over-after');
         });
        dragStartIndex = -1; // Reset drag start index
    });
    // --- DRAG & DROP & CATEGORY MANAGEMENT END ---


    function populateExerciseCategoryDropdown() {
        const catSel = document.getElementById('ex-cat');
        const currentCatValue = catSel.value; // Preserve current selection if possible
        catSel.innerHTML = ''; // Clear existing options

        const categoriesToDisplay = allCategories(); // Use the categoryOrder

        if (categoriesToDisplay.length === 0) {
            catSel.innerHTML = '<option value="">No Categories Available</option>';
             // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
             // Disable the select if no categories
            catSel.disabled = true;
             // --- DRAG & DROP & CATEGEMENT END ---
            return;
        }

         // --- DRAG & DROP & CATEGORY MANAGEMENT START ---
        catSel.disabled = false;
         // --- DRAG & DROP & CATEGEMENT END ---

        categoriesToDisplay.forEach(c => {
            catSel.add(new Option(c, c));
        });

        // Try to reselect previous value, or first if not found
        if (categoriesToDisplay.map(c => c.toLowerCase()).includes(currentCatValue.toLowerCase())) {
            const actualCat = categoriesToDisplay.find(c => c.toLowerCase() === currentCatValue.toLowerCase());
            catSel.value = actualCat;
        } else if (categoriesToDisplay.length > 0) {
            catSel.selectedIndex = 0; // Default to first if not found and options exist
        }
    }

    document.getElementById('delete-btn').onclick=()=>{
        // Stop any active timer before deleting an exercise
        stopTimer();

        if(editIndex!==null && confirm('Are you sure you want to delete this exercise?')){
            exercises.splice(editIndex,1); saveExercises(); closeModal(); renderExercises();
        }
    };

    function openModal(idx=null){
        // Stop any active timer before opening modal to edit exercises
        stopTimer();

        editIndex=idx;
        document.getElementById('modal-overlay').classList.add('active');
        document.getElementById('modal').classList.add('active');
        const nameInput=document.getElementById('ex-name');
        const catSel=document.getElementById('ex-cat');
        const weightNumInput=document.getElementById('ex-weight-num'); // New weight input
        const repsNumInput=document.getElementById('ex-reps-num'); // New reps input
        const durationTextInput=document.getElementById('ex-duration-text'); // New duration input

        const modalTitle = document.getElementById('modal-title-ex');

        populateExerciseCategoryDropdown(); // Ensure dropdown is fresh

        if(idx!==null){ // Editing existing exercise
            modalTitle.textContent = "Edit Exercise";
            const ex=exercises[idx];
            nameInput.value=ex.name;

            // Set category, handle if category was renamed/deleted
            const currentExerciseCategory = ex.category || "";
            const availableCategories = allCategories(); // Use the categoryOrder
            const categoryExists = availableCategories.some(c => c.toLowerCase() === currentExerciseCategory.toLowerCase());

            if (categoryExists) {
                const actualCat = availableCategories.find(c => c.toLowerCase() === currentExerciseCategory.toLowerCase());
                catSel.value = actualCat;
            } else if (availableCategories.length > 0) {
                catSel.selectedIndex = 0; // Default to first if current doesn't exist
                // Optionally alert user: alert(`Category "${currentExerciseCategory}" no longer exists. Please select a new one.`);
            } else {
                // catSel already shows "No Categories Available" from populateExerciseCategoryDropdown
            }

            // Populate new weight field
            weightNumInput.value = (ex.weight !== undefined && ex.weight !== null) ? ex.weight : ''; // Use new weight property

            // Populate new reps/duration fields
            repsNumInput.value = (ex.reps !== undefined && ex.reps !== null) ? ex.reps : ''; // Use new reps property
            durationTextInput.value = (ex.duration !== undefined && ex.duration !== null) ? ex.duration : ''; // Use new duration property


            document.getElementById('delete-btn').style.display='inline-block';
        } else { // Adding new exercise
            modalTitle.textContent = "Add Exercise";
            nameInput.value='';
            if (allCategories().length > 0) catSel.selectedIndex = 0;
            // else catSel shows "No Categories Available"
            weightNumInput.value = ''; // Clear new weight input
            repsNumInput.value = ''; // Clear new reps input
            durationTextInput.value = ''; // Clear new duration input
            document.getElementById('delete-btn').style.display='none';
        }

        const schedDiv=document.getElementById('schedule-inputs');
        schedDiv.innerHTML='';
        WEEKDAYS.forEach((day,i)=>{
            const dayContainer = document.createElement('div');
            const lbl=document.createElement('label');
            lbl.className='modal-label'; lbl.textContent=day; lbl.htmlFor = `sch_${i}`;
            const num=document.createElement('input');
            num.type='number'; num.min='0'; num.max='20';
            num.className='modal-number modal-input'; num.id=`sch_${i}`;
            // Get scheduled sets for this day, default to 0
            const scheduledSets = (idx!==null && exercises[idx].schedule && exercises[idx].schedule[i]) ? exercises[idx].schedule[i] : 0;
            num.value = scheduledSets;

            // Add grey-zero class if value is 0
            if (parseInt(num.value) === 0) { // Check parsed value just in case input starts with non-numeric leading chars (though type="number" prevents this)
                num.classList.add('grey-zero');
            }


            // Add event listeners for grey-zero behavior
            num.addEventListener('focus', function() {
                this.classList.remove('grey-zero'); // Remove grey class on focus
                 // If value is 0, select the text to make typing over it easy
                 if (parseInt(this.value) === 0) {
                     this.select();
                 }
            });

            num.addEventListener('blur', function() {
                // If value is empty or parsed as 0, set to "0" and add grey class
                const val = parseInt(this.value);
                if (this.value.trim() === '' || isNaN(val) || val <= 0) {
                     this.value = 0;
                    this.classList.add('grey-zero');
                } else {
                     // Ensure value is a positive number, remove grey class
                    this.value = val; // Set value to the parsed integer to clean it up
                    this.classList.remove('grey-zero');
                }
            });

             num.addEventListener('input', function() {
                // Remove grey class if user starts typing a non-zero number
                const val = parseInt(this.value);
                if (!isNaN(val) && val > 0) {
                    this.classList.remove('grey-zero');
                } else if (this.value.trim() === '0') {
                     this.classList.add('grey-zero');
                 }
                 // If input becomes empty (e.g., backspace), the blur listener will handle setting back to 0
            });


            dayContainer.appendChild(lbl); dayContainer.appendChild(num);
            schedDiv.appendChild(dayContainer);
        });
    }
    function closeModal(){
        document.getElementById('modal-overlay').classList.remove('active');
        document.getElementById('modal').classList.remove('active');
        editIndex = null;
        // Re-render exercises to ensure timer state is correct (buttons disabled/enabled)
        renderExercises();
    }
    document.getElementById('add-exercise-btn').onclick=()=>openModal(null);
    document.getElementById('modal-overlay').onclick=closeModal;

    document.getElementById('save-btn').onclick=()=>{
        const name=document.getElementById('ex-name').value.trim();
        if(!name){ alert("Please enter an exercise name."); return; }
        const category=document.getElementById('ex-cat').value;
        if(!category || category === "" || category === "No Categories Available"){ alert("Please select or create a category."); return; }

        // Get value from new weight field
        const weightNumValue = parseFloat(document.getElementById('ex-weight-num').value); // Use parseFloat for potentially decimal weights
        let weight = null;
        if (!isNaN(weightNumValue) && weightNumValue >= 0) { // Allow saving 0 weight
             weight = weightNumValue;
        }


        // Get values from new reps/duration fields
        const repsNumValue = parseInt(document.getElementById('ex-reps-num').value);
        const durationTextValue = document.getElementById('ex-duration-text').value.trim();

        let reps = null;
        let duration = null;

        // Determine whether to save reps or duration
        const hasRepsInput = !isNaN(repsNumValue) && repsNumValue > 0; // Only consider reps > 0
        const parsedDurationSeconds = parseDurationString(durationTextValue); // Get parsed value
        const hasParsableDuration = parsedDurationSeconds !== null && parsedDurationSeconds > 0; // Check if parsable and positive
        const hasAnyDurationText = durationTextValue !== ''; // Check if any text was entered

        // Validation: Prevent saving both if both reps > 0 AND parsable duration > 0 exist
        if (hasRepsInput && hasParsableDuration) {
             alert("Please enter either a valid Reps number OR a valid Duration (like 30s or 1m), not both. Text duration like 'Max hold' is fine with Reps.");
             return; // Prevent saving both
        }

        // Save Logic:
        if (hasRepsInput) {
            reps = repsNumValue;
            duration = null; // Clear duration if reps are saved
        } else if (hasAnyDurationText) {
             // If there is duration text, save it regardless of whether it's parsable
             duration = durationTextValue;
             reps = null; // Clear reps if duration text is saved
        } else {
             // Neither reps input > 0 nor any duration text was entered
             reps = null;
             duration = null;
        }


        const sched={};
        WEEKDAYS.forEach((_,i)=>{
            const valInput = document.getElementById(`sch_${i}`);
            if (valInput) {
                // Use the potentially greyed value, parse as int
                const v=parseInt(valInput.value)||0; // parseInt("") is NaN, ||0 handles this
                if(v>0) sched[i]=v;
            }
        });
        if(Object.keys(sched).length === 0 && !confirm("This exercise has no scheduled days. Save anyway?")) return;

        // Save with new weight, reps, duration properties
        const obj={name,category,weight,reps,duration,schedule:sched,progress:{}};

        if(editIndex!==null) exercises[editIndex]=obj;
        else exercises.push(obj);
        saveExercises(); closeModal(); renderExercises();
    };
    document.getElementById('reset-btn').onclick=()=>{
        // Stop any active timer before resetting progress
        stopTimer();

        if (exercises.length === 0) { alert("No exercises to reset."); return; }
        if(confirm('Are you sure you want to reset all progress for the current profile?')){
            exercises.forEach(e=>e.progress={});
            saveExercises(); renderExercises();
        }
    };

    function renderExercises(){
        document.getElementById('view-headline').textContent = isWeekly ? 'Weekly Planner' : 'Exercise Overview';
        const c=document.getElementById('tracker-content');
        c.innerHTML='';
         // Ensure collapsedCategories is loaded/initialized before rendering
        if (typeof collapsedCategories !== 'object' || collapsedCategories === null) {
             // This case should ideally not happen if load logic is correct, but as fallback
             console.warn("collapsedCategories was not loaded correctly, initializing empty.");
             collapsedCategories = {}; // Default to empty object if not loaded
        }

        if (exercises.length === 0) {
            c.innerHTML = `<p style="text-align:center; color:#777; margin-top:30px;">No exercises for "${currentProfile}". Click "Add New Exercise".</p>`;
            updateProgress();
            stopTimer(); // Ensure timer is stopped if rendering an empty list
            return;
        }


        if(isWeekly) renderWeekly(c);
        else renderByCategory(c);
        updateProgress();

        // After rendering, check if a timer was active for an exercise that still exists
        // and ensure its state is correctly reflected (Stop button shown, disabled others)
         if (activeTimer) {
             const exerciseRow = document.querySelector(`.exercise-row[data-exercise-index="${activeTimer.exerciseIndex}"]`);
             if (exerciseRow) {
                 const currentButton = exerciseRow.querySelector('.timer-control');
                 const currentDisplay = exerciseRow.querySelector('.timer-display');

                 if (currentButton && currentDisplay) {
                     // Timer was active for this exercise, ensure the Stop button is correctly rendered
                     if (!currentButton.classList.contains('stop')) {
                         // The button was likely re-rendered as a Start button, replace it
                          const stopButton = document.createElement('button');
                          stopButton.className = 'timer-control stop';
                          stopButton.textContent = 'Stop'; // Stop button uses text

                          // Re-add stop listener to the *new* stop button element
                          stopButton.onclick = (e) => { e.stopPropagation(); stopTimer(); };

                          currentButton.parentNode.replaceChild(stopButton, currentButton);
                          activeTimer.timerButton = stopButton; // Update the reference in activeTimer
                     }

                     // Ensure the display is active and showing correct time/state
                     currentDisplay.classList.add('active');
                     currentDisplay.classList.remove('finished'); // Ensure finished class is removed if it was there
                     // Update display text based on current state (remaining time or "Done!")
                     if (activeTimer.remainingSeconds > 0) {
                         currentDisplay.textContent = formatTime(activeTimer.remainingSeconds);
                     } else {
                         // If remaining was 0 or less when rendered, assume it finished just before re-render
                         currentDisplay.textContent = 'Done!';
                         currentDisplay.classList.add('finished');
                     }


                     // Disable all other start buttons
                     document.querySelectorAll('.timer-control.start-grey').forEach(btn => {
                         if (btn !== activeTimer.timerButton) { // Check against the active (now Stop) button
                              btn.disabled = true;
                         }
                     });

                 } else {
                     // Exercise row or timer elements not found (e.g., exercise deleted) - stop the timer
                     console.warn(`Timer active for index ${activeTimer.exerciseIndex}, but exercise row/elements not found. Stopping timer.`);
                     stopTimer();
                 }
             } else {
                 // Exercise row not found (e.g., exercise deleted) - stop the timer
                 console.warn(`Timer active for index ${activeTimer.exerciseIndex}, but exercise row not found. Stopping timer.`);
                 stopTimer();
             }
         }
    }

    function renderByCategory(cont){
        const groupedExercises = {};
        const categoriesInOrder = allCategories(); // Use the categoryOrder

        // Initialize groups based on the current order
        categoriesInOrder.forEach(cat => groupedExercises[cat] = []);
        // Add a group for uncategorized exercises
        const uncategorizedName = "Uncategorized";
         groupedExercises[uncategorizedName] = [];


        exercises.forEach((ex, idx) => {
            // Find the canonical category name (case-insensitive match) in the *current* categoryOrder
            const canonicalCat = categoriesInOrder.find(c => c.toLowerCase() === (ex.category || "").toLowerCase());

            if (canonicalCat) {
                 // Add exercise to the correctly cased canonical category group
                 if (!groupedExercises[canonicalCat]) groupedExercises[canonicalCat] = []; // Should exist, but defensive
                 groupedExercises[canonicalCat].push({ e: ex, idx });
            } else {
                // Handle exercises with a category that no longer exists in categoryOrder
                 groupedExercises[uncategorizedName].push({ e: ex, idx });
            }
        });

        // Render categories in the specified order
        categoriesInOrder.forEach(cat=>{
            const items = groupedExercises[cat];
            if(!items || items.length === 0) return; // Skip if no exercises in this category

            const h=document.createElement('div');
            h.className='section-header';
            // Use category name for collapsedCategories key
            h.onclick=()=>{
                // Ensure collapsedCategories is an object before toggling
                if (typeof collapsedCategories !== 'object' || collapsedCategories === null) collapsedCategories = {};
                collapsedCategories[cat]=!collapsedCategories[cat];
                // Save to profile-specific key
                localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                renderExercises(); // Rerender to show/hide content
            };
            // --- MODIFIED: Use textContent for category name, create span separately ---
            const h2 = document.createElement('h2');
            h2.textContent = cat; // Use textContent - SAFE
            const span = document.createElement('span');
            // Check collapsed state from the loaded/saved object
            span.textContent = collapsedCategories[cat]?'+':'-'; // Use textContent - SAFE
            h.appendChild(h2);
            h.appendChild(span);
            // --- END MODIFIED ---

            cont.appendChild(h);
            // Check collapsed state from the loaded/saved object before rendering content
            if(!collapsedCategories[cat]){
                const d=document.createElement('div');
                d.className='section-content';
                items.forEach(({e, idx}) => d.appendChild(renderExerciseRow(e, idx)));
                cont.appendChild(d);
            }
        });

         // Always render Uncategorized at the end if it has exercises
        if (groupedExercises[uncategorizedName].length > 0) {
             const items = groupedExercises[uncategorizedName];
             const h=document.createElement('div');
            h.className='section-header';
            // Use "Uncategorized" as the key for collapsed state
            h.onclick=()=>{
                 // Ensure collapsedCategories is an object before toggling
                 if (typeof collapsedCategories !== 'object' || collapsedCategories === null) collapsedCategories = {};
                collapsedCategories[uncategorizedName]=!collapsedCategories[uncategorizedName];
                // Save to profile-specific key
                localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                renderExercises(); // Re-render to show/hide content
            };
            // --- MODIFIED: Use textContent for category name, create span separately ---
            const h2 = document.createElement('h2');
            h2.textContent = uncategorizedName; // Use textContent - SAFE
            const span = document.createElement('span');
            // Check collapsed state from the loaded/saved object
            span.textContent = collapsedCategories[uncategorizedName]?'+':'-'; // Use textContent - SAFE
            h.appendChild(h2);
            h.appendChild(span);
            // --- END MODIFIED ---

            cont.appendChild(h);
            // Check collapsed state from the loaded/saved object before rendering content
            if(!collapsedCategories[uncategorizedName]){
                const d=document.createElement('div');
                d.className='section-content';
                items.forEach(({e,idx})=>d.appendChild(renderExerciseRow(e, idx)));
                cont.appendChild(d);
            }
        }
    }

    function renderWeekly(cont){
        const byDay={};
        WEEKDAYS.forEach(d=>byDay[d]=[]);
        exercises.forEach((e,idx)=>{
            if (e.schedule) {
                Object.entries(e.schedule).forEach(([dayIndex,count])=>{
                    const dayIndexInt = parseInt(dayIndex);
                    if(!isNaN(dayIndexInt) && WEEKDAYS[dayIndexInt] && count > 0) {
                       byDay[WEEKDAYS[dayIndexInt]].push({e, idx, count});
                    }
                });
            }
        });
        WEEKDAYS.forEach(day=>{
            const dayItems = byDay[day];
            if(!dayItems.length)return;
            const h=document.createElement('div');
            h.className='section-header';
            // Use day name for collapsedCategories key
            h.onclick=()=>{
                 // Ensure collapsedCategories is an object before toggling
                 if (typeof collapsedCategories !== 'object' || collapsedCategories === null) collapsedCategories = {};
                collapsedCategories[day]=!collapsedCategories[day];
                // Save to profile-specific key
                localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
                renderExercises(); // Re-render to show/hide content
            };
            // --- MODIFIED: Use textContent for day name, create span separately ---
            const h2 = document.createElement('h2');
            h2.textContent = day; // Use textContent - SAFE (day names are static)
            const span = document.createElement('span');
            // Check collapsed state from the loaded/saved object
            span.textContent = collapsedCategories[day]?'+':'-'; // Use textContent - SAFE
            h.appendChild(h2);
            h.appendChild(span);
            // --- END MODIFIED ---

            cont.appendChild(h);
            // Check collapsed state from the loaded/saved object before rendering content
            if(!collapsedCategories[day]){
                const d=document.createElement('div');
                d.className='section-content';
                dayItems.forEach(({e,idx,count})=>d.appendChild(renderExerciseRow(e,idx,count,day)));
                cont.appendChild(d);
            }
        });
    }

    function renderExerciseRow(exercise, index, setsCountForDay, dayKey){
        const row=document.createElement('div');
        row.className='exercise-row';
        // Add a data attribute to identify the exercise by its index for timer purposes
        row.setAttribute('data-exercise-index', index);

        const headerRow=document.createElement('div'); headerRow.className='header-row'; // flex container

        const nameDiv=document.createElement('div'); nameDiv.className='name'; nameDiv.textContent=exercise.name;

        // Controls (edit button) - remains a separate flex item, auto margin pushes it right
        const controlsDiv = document.createElement('div');
        const editBtn=document.createElement('button');
        editBtn.className='edit-button';
        // Use PEN icon SVG instead of text
        editBtn.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75l1.83-1.83z"/></svg>';
        editBtn.title = "Edit Exercise";

        editBtn.onclick=(e)=>{ e.stopPropagation(); openModal(index); };
        controlsDiv.appendChild(editBtn);

        // Append name and controls to the header row
        headerRow.appendChild(nameDiv);
        headerRow.appendChild(controlsDiv); // Place controls last in the flex container

        row.appendChild(headerRow); // Add header row to main row


        // Display Weight, Reps, or Duration based on properties, in one line
        const detailsParts = [];
        // Calculate duration in seconds from the exercise object's duration string
        const durationInSeconds = parseDurationString(exercise.duration || "");


        // Add Weight if available and > 0
        if (exercise.weight !== undefined && exercise.weight !== null && typeof exercise.weight === 'number' && exercise.weight > 0) {
            const formattedWeight = Number.isInteger(exercise.weight) ? exercise.weight : exercise.weight.toFixed(1);
            detailsParts.push(`${formattedWeight} kg`);
        }

        // Add Reps if available and > 0
        if (exercise.reps !== undefined && exercise.reps !== null && typeof exercise.reps === 'number' && exercise.reps > 0) {
            detailsParts.push(`${exercise.reps} reps`);
        }

        // Add Duration text if available (even non-parsable text)
        if (exercise.duration !== undefined && exercise.duration !== null && exercise.duration.trim() !== "") {
             detailsParts.push(exercise.duration.trim()); // Add the original duration text
        }


        // Container for the details text and the timer elements
        const detailsTimerContainer = document.createElement('div');
        detailsTimerContainer.className = 'reps-duration'; // Reuse the reps-duration class styling


         // Add the formatted details text if available
        if (detailsParts.length > 0) {
            const detailsTextSpan = document.createElement('span');
            detailsTextSpan.textContent = detailsParts.join(' / ');
             detailsTimerContainer.appendChild(detailsTextSpan);
        }

        // Timer Elements Container
        const timerElementsContainer = document.createElement('div');
        timerElementsContainer.className = 'timer-container'; // Use new container for right alignment


         // Add timer elements ONLY if duration is valid and positive (parsed duration)
         if (durationInSeconds !== null && durationInSeconds > 0) {
             const timerDisplay = document.createElement('span');
             timerDisplay.className = 'timer-display';
             // Initial display text is the full duration
             timerDisplay.textContent = formatTime(durationInSeconds);


             const timerButton = document.createElement('button');
             timerButton.className = 'timer-control start-grey'; // Add grey class for Start
             timerButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-.5 15.5V12h-3v-1h4v6.5h-1z"/></svg>'; // Timer icon SVG
             timerButton.title = "Start Timer"; // Tooltip


             // Disable the button if another timer is already active
             if (activeTimer) {
                 timerButton.disabled = true;
             }

             // Add event listener to start the timer
             timerButton.onclick = (e) => {
                 e.stopPropagation(); // Prevent triggering exercise edit or section collapse
                 if (!activeTimer && durationInSeconds > 0) { // Double-check duration validity before starting
                     // Pass the found DOM elements to startTimer
                     startTimer(index, durationInSeconds, row, timerDisplay, timerButton);
                 }
             };

             timerElementsContainer.appendChild(timerDisplay);
             timerElementsContainer.appendChild(timerButton);

             // Add the timer elements container to the main details/timer line
             detailsTimerContainer.appendChild(timerElementsContainer);
         }


        // Only append the detailsTimerContainer if it has any children (details or timer elements)
        if (detailsTimerContainer.hasChildNodes()) {
             row.appendChild(detailsTimerContainer);
        }


        const checkboxGroupOuter = document.createElement('div');

        if(isWeekly && dayKey != null && setsCountForDay != null){
            const checkboxGroup=document.createElement('div'); checkboxGroup.className='checkbox-group';
            for(let k=0;k<setsCountForDay;k++){
                const cb=document.createElement('input'); cb.type='checkbox';
                const progressKey=`${dayKey}-${index}-${k}`;
                cb.checked=!!(exercise.progress&&exercise.progress[progressKey]);
                cb.onchange=()=>{
                    exercise.progress=exercise.progress||{};
                    exercise.progress[progressKey]=cb.checked;
                    saveExercises(); updateProgress();
                };
                checkboxGroup.appendChild(cb);
            }
            if (checkboxGroup.hasChildNodes()) checkboxGroupOuter.appendChild(checkboxGroup);
        } else if (!isWeekly) {
            let totalScheduledSets = 0;
            if(exercise.schedule) Object.values(exercise.schedule).forEach(count => totalScheduledSets += count);

            if (totalScheduledSets > 0) {
                Object.entries(exercise.schedule).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).forEach(([dayIndexStr,count])=>{
                    const dayIndex = parseInt(dayIndexStr);
                    if (count > 0 && dayIndex >= 0 && dayIndex < WEEKDAYS.length) {
                        const weekdayRow = document.createElement('div'); weekdayRow.className = 'weekday-row';
                        const weekdayLabel = document.createElement('span');
                        weekdayLabel.className = 'weekday-label'; weekdayLabel.textContent = WEEKDAYS[dayIndex];
                        const singleDayCheckboxGroup = document.createElement('div'); singleDayCheckboxGroup.className = 'checkbox-group';
                        for(let k=0;k<count;k++){
                            const cb=document.createElement('input'); cb.type='checkbox';
                            const currentDayKey = WEEKDAYS[dayIndex];
                            const progressKey=`${currentDayKey}-${index}-${k}`;
                            cb.checked=!!(exercise.progress&&exercise.progress[progressKey]);
                            cb.onchange=()=>{
                                exercise.progress=exercise.progress||{};
                                exercise.progress[progressKey]=cb.checked;
                                saveExercises(); updateProgress();
                            };
                            singleDayCheckboxGroup.appendChild(cb);
                        }
                        weekdayRow.appendChild(weekdayLabel); weekdayRow.appendChild(singleDayCheckboxGroup);
                        checkboxGroupOuter.appendChild(weekdayRow);
                    }
                });
            } else {
                 const noScheduleInfo = document.createElement('div');
                 noScheduleInfo.className = 'reps-duration'; noScheduleInfo.textContent = 'Not scheduled.';
                 noScheduleInfo.style.fontStyle = 'italic'; checkboxGroupOuter.appendChild(noScheduleInfo);
            }
        }
        if (checkboxGroupOuter.hasChildNodes()) row.appendChild(checkboxGroupOuter);
        return row;
    }

     // Helper function to parse duration string (returns seconds or null if not parsable)
     function parseDurationString(durationString) {
        if (!durationString || typeof durationString !== 'string') return null;

        let totalSeconds = 0;
        const lowerDuration = durationString.toLowerCase().trim();

        // Handle H:M:SS or M:SS format
        const parts = lowerDuration.split(':').map(p => parseInt(p));
        if (parts.length > 1 && parts.every(p => !isNaN(p) && p >= 0)) {
             if (parts.length === 2) { // M:SS
                totalSeconds = parts[0] * 60 + parts[1];
            } else if (parts.length === 3) { // H:M:SS
                totalSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            return totalSeconds > 0 ? totalSeconds : null; // Return null for 0 duration from M:SS/H:M:SS
        }

        // Handle units like '30s', '1m 30s', '2min', '1hr'
        // Use a separate regex execution variable to avoid state issues with global regex flag 'g'
        const tempRegex = /(\d+)\s*(h(?:r)?|m(?:in)?|s(?:ec)?)/g;
        let match;
        let unitFound = false;

        while ((match = tempRegex.exec(lowerDuration)) !== null) {
            const value = parseInt(match[1]);
            const unit = match[2];
            if (!isNaN(value) && value >= 0) {
                unitFound = true;
                if (unit.startsWith('h')) {
                    totalSeconds += value * 3600;
                } else if (unit.startsWith('m')) {
                    totalSeconds += value * 60;
                } else if (unit.startsWith('s')) {
                    totalSeconds += value;
                }
            }
        }

         // If units were found, use the calculated totalSeconds
         if (unitFound) {
             return totalSeconds > 0 ? totalSeconds : null; // Return null for 0 duration if units were used
         }

        // If no units or H:M:SS format matched, check if it's just a simple number (interpreted as seconds)
        const simpleNumber = parseInt(lowerDuration);
         // Check if the parsed number *exactly* matches the trimmed input string to avoid parsing "30s" as 30
         if (!isNaN(simpleNumber) && simpleNumber >= 0 && String(simpleNumber) === lowerDuration) {
             return simpleNumber > 0 ? simpleNumber : null; // Return null for 0 duration if simple number is 0
        }


        return null; // Return null if parsing fails for everything
     }


    // Helper function to format seconds into MM:SS or H:MM:SS
    function formatTime(seconds) {
        if (seconds < 0) seconds = 0; // Don't show negative time
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = seconds % 60;

        const paddedMinutes = minutes.toString().padStart(2, '0');
        const paddedSeconds = remainingSeconds.toString().padStart(2, '0');

        if (hours > 0) {
            return `${hours}:${paddedMinutes}:${paddedSeconds}`;
        } else {
            return `${minutes}:${paddedSeconds}`;
        }
    }

    // Start the timer
    function startTimer(exerciseIndex, durationInSeconds, exerciseElement, displayElement, startButton) {
        // Stop any existing timer first
        stopTimer();

        // Ensure elements are valid before proceeding
        if (!exerciseElement || !displayElement || !startButton) {
            console.error("startTimer called with invalid elements.");
            return;
        }

        const stopButton = document.createElement('button');
        stopButton.className = 'timer-control stop'; // Add magenta class
        stopButton.textContent = 'Stop'; // Stop button uses text

        // Replace the start button with the stop button
        startButton.parentNode.replaceChild(stopButton, startButton);

         // Disable all other start buttons
         document.querySelectorAll('.timer-control.start-grey').forEach(btn => {
             btn.disabled = true;
         });


        let remainingSeconds = durationInSeconds;
        displayElement.textContent = formatTime(remainingSeconds);
        displayElement.classList.add('active'); // Show the display element
        displayElement.classList.remove('finished'); // Ensure finished class is removed

        const intervalId = setInterval(() => {
            remainingSeconds--;
            activeTimer.remainingSeconds = remainingSeconds; // Update remaining seconds in the active timer object
            displayElement.textContent = formatTime(remainingSeconds);

            if (remainingSeconds <= 0) {
                stopTimer(true); // Use stopTimer with 'finished' flag

                 // Optionally play a sound or vibrate
                 try {
                     // Check if Notification permission is granted, ask if not, and show a notification
                     if (Notification.permission === 'granted') {
                         new Notification(`Timer Finished: ${exercises[exerciseIndex].name}`);
                     } else if (Notification.permission !== 'denied') {
                         Notification.requestPermission().then(permission => {
                             if (permission === 'granted') {
                                 new Notification(`Timer Finished: ${exercises[exerciseIndex].name}`);
                             }
                         });
                     }
                 } catch (e) {
                      console.error("Notification failed:", e);
                 }
                 try { navigator.vibrate(2000); } catch(e) { console.error("Vibration failed:", e); } // Vibrate for 2 seconds

            }
        }, 1000);

        // Store timer state
        activeTimer = {
            intervalId: intervalId,
            exerciseIndex: exerciseIndex, // Store exercise index
            exerciseElement: exerciseElement, // Store reference to the exercise row element
            initialSeconds: durationInSeconds, // Store initial duration
            remainingSeconds: remainingSeconds, // Store current remaining time
            displayElement: displayElement, // Store reference to the timer display element
            timerButton: stopButton // Store the current button reference (which is now the stop button)
        };

        // Add event listener to the stop button
        stopButton.onclick = (e) => {
            e.stopPropagation();
            stopTimer(); // Stop manually
        };
         console.log(`Timer started for exercise index ${exerciseIndex}`);
    }

    // Stop the currently active timer
    // Optional parameter `finished` to indicate if timer finished naturally
    function stopTimer(finished = false) {
        if (activeTimer) {
             console.log(`Stopping timer for index ${activeTimer.exerciseIndex}. Finished: ${finished}`);
            clearInterval(activeTimer.intervalId);

             // Find the exercise row again in case the DOM was re-rendered
            const exerciseRow = document.querySelector(`.exercise-row[data-exercise-index="${activeTimer.exerciseIndex}"]`);
            // Find the current display and button elements within the current DOM structure
             const currentDisplay = exerciseRow ? exerciseRow.querySelector('.timer-display') : activeTimer.displayElement; // Fallback to stored ref if row not found
             const currentButton = exerciseRow ? exerciseRow.querySelector('.timer-control') : activeTimer.timerButton; // Fallback to stored ref

             // Ensure the display is updated and classes are reset
            if (currentDisplay) {
                 currentDisplay.classList.remove('active'); // Hide the display element
                 currentDisplay.classList.remove('finished'); // Remove finished class

                 // Reset text content to initial duration format, unless it finished naturally
                 if (!finished && activeTimer.initialSeconds !== null) {
                      currentDisplay.textContent = formatTime(activeTimer.initialSeconds); // Reset to original time
                 } else if (finished) {
                      currentDisplay.textContent = 'Done!'; // Keep "Done!" if it finished naturally
                      currentDisplay.classList.add('finished'); // Add finished class back if it finished naturally
                 } else if (activeTimer.initialSeconds !== null) {
                     // Fallback if not finished but initialSeconds is known
                      currentDisplay.textContent = formatTime(activeTimer.initialSeconds);
                 } else {
                      currentDisplay.textContent = formatTime(0); // Default to 0:00 if initial is unknown
                 }
            } else {
                 console.warn("Timer display element not found during stopTimer.");
            }


             // Ensure the button is correctly reset (from Stop back to Start) if it's still the Stop button
            if (currentButton && currentButton.classList.contains('stop')) {
                 const newStartButton = document.createElement('button');
                 newStartButton.className = 'timer-control start-grey'; // Set grey class
                 newStartButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-.5 15.5V12h-3v-1h4v6.5h-1z"/></svg>'; // Timer icon SVG
                 newStartButton.title = "Start Timer"; // Tooltip

                 // Re-attach the click listener to the new start button
                 // Need to find the exercise object and its duration again as activeTimer is about to be cleared
                 const exercise = exercises[activeTimer.exerciseIndex];
                 const durationInSeconds = parseDurationString(exercise.duration || ""); // Ensure duration is retrieved

                 if (exerciseRow && currentDisplay) { // Ensure necessary elements are found
                       if (durationInSeconds !== null && durationInSeconds > 0) {
                            // Use a closure to capture index, duration, row, and display for the new button's click handler
                           newStartButton.onclick = (function(idx, dur, rowEl, dispEl, btnEl) {
                                return function(e) {
                                   e.stopPropagation();
                                    // Before starting, check if another timer became active since this button was created
                                   if (!activeTimer) {
                                       startTimer(idx, dur, rowEl, dispEl, btnEl);
                                   } else {
                                       console.log("Tried to start timer, but another is active.");
                                   }
                               };
                            })(activeTimer.exerciseIndex, durationInSeconds, exerciseRow, currentDisplay, newStartButton); // Pass elements and values
                           newStartButton.disabled = false; // Ensure it's enabled if duration is valid
                       } else {
                           // This case shouldn't happen if a timer was started, but defensive
                           newStartButton.disabled = true; // Disable if duration is now invalid/zero
                       }
                       // Replace the button in the DOM
                       currentButton.parentNode.replaceChild(newStartButton, currentButton);
                 } else {
                     console.warn("Could not find exercise row or display element to replace timer button.");
                 }
            } else if (currentButton && currentButton.classList.contains('start-grey')) {
                 // If for some reason the button was already a start button, just ensure it's enabled
                 currentButton.disabled = false;
            } else {
                 console.warn("Could not find timer button during stopTimer.");
            }

             // Re-enable all start buttons regardless
             document.querySelectorAll('.timer-control.start-grey').forEach(btn => {
                 btn.disabled = false;
             });


            activeTimer = null; // Clear the active timer state
             console.log("activeTimer set to null.");
        }
    }


    function updateProgress(){
        let totalSets=0, completedSets=0;
        exercises.forEach((ex, exerciseIdx) => {
            if (ex.schedule) {
                Object.entries(ex.schedule).forEach(([dayIndexStr, setCount]) => {
                    const dayIndex = parseInt(dayIndexStr);
                    if (!isNaN(dayIndex) && dayIndex >= 0 && dayIndex < WEEKDAYS.length) {
                        totalSets += setCount;
                        const dayKey = WEEKDAYS[dayIndex];
                        if (dayKey) {
                            for (let k = 0; k < setCount; k++) {
                                const progressKey = `${dayKey}-${exerciseIdx}-${k}`;
                                if (ex.progress && ex.progress[progressKey]) completedSets++;
                            }
                        }
                    }
                });
            }
        });
        const percentage = totalSets > 0 ? Math.round((completedSets / totalSets) * 100) : 0;
        document.getElementById('progress-fill').style.width = percentage + '%';
        document.getElementById('progress-label').textContent = percentage + '%';

         // Confetti Trigger
         if (percentage === 100 && previousProgressPercentage < 100) {
             triggerConfetti();
         }
         previousProgressPercentage = percentage; // Store current percentage for next update
    }

    // Function to trigger confetti animation
    function triggerConfetti() {
         const confettiContainer = document.createElement('div');
         confettiContainer.className = 'confetti';
         document.body.appendChild(confettiContainer);

         const colors = ['cyan', 'magenta', 'yellow'];
         const numberOfParticles = 100; // Adjust as needed

         for (let i = 0; i < numberOfParticles; i++) {
             const particle = document.createElement('div');
             particle.className = 'confetti-particle';

             const color = colors[Math.floor(Math.random() * colors.length)];
             particle.style.backgroundColor = color;

             // Randomize start position (top of screen, spread horizontally)
             const startX = Math.random() * window.innerWidth;
             const startY = -20; // Start slightly above the viewport

             // Randomize end position and rotation
             const endX = startX + (Math.random() - 0.5) * 400; // Horizontal spread
             const endY = window.innerHeight + 20; // Fall below viewport

             const rotateDeg = Math.random() * 1000 - 500; // Random rotation

             particle.style.left = `${startX}px`;
             particle.style.top = `${startY}px`;

             // Set CSS variables for animation
             particle.style.setProperty('--fall-x', `${endX - startX}px`);
             particle.style.setProperty('--fall-y', `${endY - startY}px`);
             particle.style.setProperty('--rotate', `${rotateDeg}deg`);


             // Set animation duration and delay
             const animationDuration = 1.5 + Math.random() * 1; // 1.5s to 2.5s
             const animationDelay = Math.random() * 1; // Up to 1s delay
             particle.style.animationDuration = `${animationDuration}s`;
             particle.style.animationDelay = `${animationDelay}s`;


             confettiContainer.appendChild(particle);

             // Remove particle after animation
             particle.addEventListener('animationend', () => {
                 particle.remove();
                 // Remove container if it's empty
                 if (confettiContainer.children.length === 0) {
                     confettiContainer.remove();
                 }
             });
         }
    }


    function ensureScheduleFormat(ex) {
        // Ensure schedule is an object
        if (!ex.schedule || typeof ex.schedule !== 'object') {
            ex.schedule = {};
        }
        const newSchedule = {};
        for (const dayIdxStr in ex.schedule) {
            const dayIdx = parseInt(dayIdxStr);
            const count = parseInt(ex.schedule[dayIdxStr]);
            if (!isNaN(dayIdx) && dayIdx >= 0 && dayIdx < WEEKDAYS.length && !isNaN(count) && count > 0) {
                newSchedule[dayIdx] = count;
            }
        }
        ex.schedule = newSchedule;

        // Ensure progress is an object
        if (!ex.progress || typeof ex.progress !== 'object') ex.progress = {};

         // Ensure weight is a number or null
         if (ex.weight !== undefined && ex.weight !== null) {
             const val = parseFloat(ex.weight);
             ex.weight = !isNaN(val) && val >= 0 ? val : null;
         } else {
              ex.weight = null; // Ensure property exists
         }

        // Ensure reps is a number or null, and duration is string or null
        // Handle potential migration from older formats where reps might have been a string like "30s"
        let tempReps = ex.reps;
        let tempDuration = ex.duration;

        // Check if 'reps' was a string in older data and duration doesn't exist
        if (typeof tempReps === 'string' && (tempDuration === undefined || tempDuration === null)) {
             const oldRepsStr = tempRps.trim();
             // Attempt to parse old string reps as a number first
             const numValue = parseInt(oldRepsStr);

             if (!isNaN(numValue) && numValue >= 0 && String(numValue) === oldRepsStr) {
                 // It was a number string, treat as reps
                 ex.reps = numValue;
                 ex.duration = null;
             } else if (oldRepsStr !== '') {
                 // It was a non-numeric string, treat as duration text
                 ex.duration = oldRepsStr;
                 ex.reps = null;
             } else {
                 // Empty string
                 ex.reps = null;
                 ex.duration = null;
             }
        } else {
             // If reps was already a number or null, ensure it remains a number or null
             const numValue = typeof tempReps === 'number' ? tempReps : parseInt(tempReps); // Parse if not already a number
              ex.reps = !isNaN(numValue) && numValue >= 0 ? numValue : null;

             // Ensure duration is a string or null
             ex.duration = (tempDuration !== undefined && tempDuration !== null) ? String(tempDuration).trim() : null;
             if (ex.duration === "") ex.duration = null; // Treat empty string duration as null
        }


        // Clean up old/unused properties if they exist
        delete ex.weekdays;
        if (ex.days && Array.isArray(ex.days)) { // Migrate old days array format to schedule object if found
             if (Object.keys(ex.schedule).length === 0) { // Only migrate if schedule is empty
                ex.days.forEach(dayIdx => {
                    if (!isNaN(dayIdx) && dayIdx >= 0 && dayIdx < WEEKDAYS.length) {
                        ex.schedule[dayIdx] = 1; // Assume 1 set if migrating from old format
                    }
                });
             }
             delete ex.days;
        }
         // Ensure no leftover string 'reps' property if it wasn't converted
         if (typeof ex.reps === 'string') {
             delete ex.reps;
             ex.reps = null;
         }


        return ex;
    }


    document.addEventListener('click', function(event) {
        const menu = document.getElementById('dropdown-menu');
        const icon = document.querySelector('.menu-icon');
        // Check if the clicked element is NOT inside the menu icon and NOT inside the menu itself, and the menu is currently showing
        if (menu && icon && menu.classList.contains('show') &&
            !icon.contains(event.target) && !menu.contains(event.target)) {
            menu.classList.remove('show');
        }
         // Also close modals if clicking outside them
         const profileModal = document.getElementById('profile-modal');
         const profileOverlay = document.getElementById('profile-modal-overlay');
         if (profileModal && profileModal.classList.contains('active') && event.target === profileOverlay) {
             closeProfileModal();
         }
          const catModal = document.getElementById('cat-modal');
         const catOverlay = document.getElementById('cat-modal-overlay');
          if (catModal && catModal.classList.contains('active') && event.target === catOverlay) {
             closeCatModal();
         }
          const mainModal = document.getElementById('modal');
         const mainOverlay = document.getElementById('modal-overlay');
          if (mainModal && mainModal.classList.contains('active') && event.target === mainOverlay) {
             closeModal();
         }

    });


    let profiles = {};
    let currentProfile = "Default";

    function loadProfiles() {
        const storedProfiles = localStorage.getItem("profiles");
        if (storedProfiles) {
            try { profiles = JSON.parse(storedProfiles); } catch(e) { profiles = {"Default": []}; console.error("Error parsing profiles from localStorage", e); }
        } else {
            profiles = { "Default": [] };
        }
        currentProfile = localStorage.getItem("currentProfile") || Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default";
        if (!profiles[currentProfile]) {
            currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default";
            if (!profiles[currentProfile] && Object.keys(profiles).length === 0) { // If profiles is truly empty
                 profiles["Default"] = [];
                 currentProfile = "Default";
            }
            localStorage.setItem("currentProfile", currentProfile);
        }
         if (Object.keys(profiles).length === 0) { // Absolute fallback
            profiles["Default"] = [];
            currentProfile = "Default";
            localStorage.setItem("currentProfile", currentProfile);
            localStorage.setItem("profiles", JSON.stringify(profiles));
        }
    }

    function loadProfileOptions() {
        const sel = document.getElementById("profile-select");
        sel.innerHTML = '';
        const sortedProfileNames = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()));


        if (sortedProfileNames.length === 0) { // Should be caught by loadProfiles
            profiles["Default"] = []; currentProfile = "Default";
            localStorage.setItem("currentProfile", currentProfile); localStorage.setItem("profiles", JSON.stringify(profiles));
            sortedProfileNames.push("Default");
        }

        sortedProfileNames.forEach(name => {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            sel.appendChild(option);
        });
        sel.value = currentProfile;
        document.getElementById('profile-container').style.display = 'flex'; // Always show if it exists
    }

    function switchProfile() {
        // Stop any active timer before switching profiles
        stopTimer();

        const selectedProfileName = document.getElementById("profile-select").value;
        if (selectedProfileName && profiles.hasOwnProperty(selectedProfileName)) {
            currentProfile = selectedProfileName;
            localStorage.setItem("currentProfile", currentProfile);
            exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);

            // Load or initialize collapsed state for the new profile
             const collapsedKey = 'collapsedCategories_' + currentProfile;
             const storedCollapsed = localStorage.getItem(collapsedKey);

             if (storedCollapsed === null) {
                 // First time loading this profile - collapse everything
                 collapsedCategories = {};
                 // Need categories to collapse, so ensure categoryOrder is loaded first
                 if (categoryOrder.length === 0) loadCategoryOrder(); // Defensive check
                 allCategories().forEach(cat => collapsedCategories[cat] = true); // Collapse categories
                 WEEKDAYS.forEach(day => collapsedCategories[day] = true); // Collapse weekdays
                  localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save the newly collapsed state
                 console.log(`Profile "${currentProfile}" loaded for the first time, collapsing sections.`);

             } else {
                // Profile has been loaded before, load saved collapsed state
                try {
                     collapsedCategories = JSON.parse(storedCollapsed);
                     console.log(`Profile "${currentProfile}" loaded, restored collapsed state.`);
                } catch (e) {
                    console.error("Error parsing collapsed state for profile", currentProfile, e);
                    collapsedCategories = {}; // Fallback to empty (uncollapsed) on parse error
                    localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save empty state
                }
             }


            renderExercises();
            populateExerciseCategoryDropdown();
        } else if (Object.keys(profiles).length > 0) { // Fallback to first profile (alphabetical)
            currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0];
            localStorage.setItem("currentProfile", currentProfile);
            document.getElementById("profile-select").value = currentProfile;
            exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);

             // Load or initialize collapsed state for the fallback profile
            const collapsedKey = 'collapsedCategories_' + currentProfile;
            const storedCollapsed = localStorage.getItem(collapsedKey);

             if (storedCollapsed === null) {
                 // First time loading this profile - collapse everything
                 collapsedCategories = {};
                 allCategories().forEach(cat => collapsedCategories[cat] = true);
                 WEEKDAYS.forEach(day => collapsedCategories[day] = true);
                 localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save the newly collapsed state
                 console.log(`Fallback profile "${currentProfile}" loaded for the first time, collapsing sections.`);

             } else {
                // Profile has been loaded before, load saved collapsed state
                try {
                     collapsedCategories = JSON.parse(storedCollapsed);
                     console.log(`Fallback profile "${currentProfile}" loaded, restored collapsed state.`);
                } catch (e) {
                    console.error("Error parsing collapsed state for fallback profile", currentProfile, e);
                    collapsedCategories = {}; // Fallback to empty (uncollapsed) on parse error
                    localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save empty state
                }
             }

            renderExercises(); populateExerciseCategoryDropdown();
        } else { // Should not be reached if loadProfiles ensures Default exists
            console.error("No profiles available to switch to.");
        }
    }

     // Save exercises AND collapsed state specific to the current profile
    function saveExercises() {
        if (!profiles[currentProfile]) profiles[currentProfile] = [];
        profiles[currentProfile] = exercises.map(ex => {
             const savedEx = {
                name: ex.name,
                category: ex.category,
                schedule: ex.schedule,
                progress: ex.progress
             };
             // Save weight only if it's a non-null number >= 0
             if (ex.weight !== undefined && ex.weight !== null && typeof ex.weight === 'number' && ex.weight >= 0) {
                 savedEx.weight = ex.weight;
             }
             // Save reps only if it's a non-null number >= 0
             if (ex.reps !== undefined && ex.reps !== null && typeof ex.reps === 'number' && ex.reps >= 0) {
                 savedEx.reps = ex.reps;
             }
              // Save duration only if it's a non-null, non-empty string
              if (ex.duration !== undefined && ex.duration !== null && typeof ex.duration === 'string' && ex.duration.trim() !== '') {
                 savedEx.duration = ex.duration.trim(); // Save trimmed duration
             }
             return savedEx;
        });
        localStorage.setItem("profiles", JSON.stringify(profiles));
         // Save collapsed state specific to the current profile
         localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
    }


    function openProfileModal() {
        document.getElementById('dropdown-menu').classList.remove('show');
        document.getElementById('profile-modal-overlay').classList.add('active');
        document.getElementById('profile-modal').classList.add('active');
        populateProfileModal();
    }
    function closeProfileModal() {
        document.getElementById('profile-modal-overlay').classList.remove('active');
        document.getElementById('profile-modal').classList.remove('active');
    }

    function populateProfileModal() {
        const list = document.getElementById('profile-list');
        list.innerHTML = '';
        const sortedProfileNames = Object.keys(profiles).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

        sortedProfileNames.forEach(name => {
            const originalName = name;

            const item = document.createElement('div');
            item.className = 'modal-item';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalName;
            nameSpan.style.flexGrow = "1";

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'modal-input list-rename-input';
            nameInput.value = originalName;
            nameInput.style.display = 'none';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.className = 'modal-button';

            const saveRenameBtn = document.createElement('button');
            saveRenameBtn.textContent = 'Save';
            saveRenameBtn.className = 'modal-button save';
            saveRenameBtn.style.display = 'none';

            const cancelRenameBtn = document.createElement('button');
            cancelRenameBtn.textContent = 'Cancel';
            cancelRenameBtn.className = 'modal-button cancel';
            cancelRenameBtn.style.display = 'none';

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'x';
            deleteBtn.className = 'modal-button delete';
            deleteBtn.disabled = (Object.keys(profiles).length <= 1); // Disable delete if only one profile exists

            const controlsDiv = document.createElement('div'); // To group buttons
            controlsDiv.style.display = 'flex'; controlsDiv.style.alignItems = 'center'; controlsDiv.style.gap = '8px';
            controlsDiv.appendChild(renameBtn); controlsDiv.appendChild(saveRenameBtn);
            controlsDiv.appendChild(cancelRenameBtn); controlsDiv.appendChild(deleteBtn);

            item.appendChild(nameSpan); item.appendChild(nameInput); item.appendChild(controlsDiv);
            list.appendChild(item);

            renameBtn.onclick = () => {
                nameSpan.style.display = 'none';
                nameInput.style.display = 'block'; nameInput.style.flexGrow = "1"; // Set flex-grow here too
                nameInput.value = nameSpan.textContent; nameInput.focus();
                renameBtn.style.display = 'none';
                saveRenameBtn.style.display = 'inline-block';
                cancelRenameBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            };
            cancelRenameBtn.onclick = () => {
                nameSpan.style.display = 'block';
                nameInput.style.display = 'none'; nameInput.style.flexGrow = "0"; // Reset flex-grow
                renameBtn.style.display = 'inline-block';
                saveRenameBtn.style.display = 'none';
                cancelRenameBtn.style.display = 'none';
                deleteBtn.style.display = 'inline-block';
            };
            saveRenameBtn.onclick = () => {
                const newNameTrimmed = nameInput.value.trim();
                if (!newNameTrimmed) {
                    alert("Profile name cannot be empty."); nameInput.focus(); return;
                }
                if (newNameTrimmed.toLowerCase() === originalName.toLowerCase() && newNameTrimmed === originalName) {
                    cancelRenameBtn.onclick(); return;
                }
                for (const existingProfileName in profiles) {
                    if (existingProfileName.toLowerCase() === newNameTrimmed.toLowerCase() && existingProfileName.toLowerCase() !== originalName.toLowerCase()) {
                        alert(`Profile name "${newNameTrimmed}" already exists or conflicts with another profile.`);
                        nameInput.focus(); return;
                    }
                }
                 // Case-insensitive rename check passed, perform the rename
                const profileData = profiles[originalName];
                delete profiles[originalName];
                profiles[newNameTrimmed] = profileData;

                 // Also rename the collapsed state key in localStorage
                 const oldCollapsedKey = 'collapsedCategories_' + originalName;
                 const newCollapsedKey = 'collapsedCategories_' + newNameTrimmed;
                 const collapsedState = localStorage.getItem(oldCollapsedKey);
                 if (collapsedState !== null) {
                      localStorage.setItem(newCollapsedKey, collapsedState);
                      localStorage.removeItem(oldCollapsedKey);
                 }


                if (currentProfile === originalName) {
                    currentProfile = newNameTrimmed;
                    localStorage.setItem("currentProfile", currentProfile);
                     // Update the current collapsed state object reference if this was the active profile
                    try {
                        collapsedCategories = JSON.parse(localStorage.getItem(newCollapsedKey)) || {};
                    } catch (e) {
                        console.error("Error loading renamed collapsed state for profile", newNameTrimmed, e);
                        collapsedCategories = {};
                    }

                }
                localStorage.setItem("profiles", JSON.stringify(profiles));
                alert(`Profile "${originalName}" renamed to "${newNameTrimmed}".`);
                populateProfileModal(); loadProfileOptions();
                if (document.getElementById("profile-select").value !== currentProfile) {
                    document.getElementById("profile-select").value = currentProfile;
                }
                if (currentProfile === newNameTrimmed && exercises === profileData) { // if current profile data was affected
                    renderExercises();
                }
            };
            deleteBtn.onclick = function() {
                if (deleteBtn.disabled) { alert("Cannot delete the last profile."); return;}
                if (confirm(`Delete profile "${originalName}"? This cannot be undone.`)) {
                     // Stop any active timer if it belongs to this profile before deleting
                     stopTimer();

                    const nameToDelete = originalName;
                    delete profiles[nameToDelete];

                     // Also remove the collapsed state key from localStorage
                     const collapsedKeyToDelete = 'collapsedCategories_' + nameToDelete;
                     localStorage.removeItem(collapsedKeyToDelete);


                    let profileSwitchedOrRefreshed = false;
                    if (currentProfile === nameToDelete) {
                        currentProfile = Object.keys(profiles).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))[0] || "Default"; // Switch to the first alphabetical
                        localStorage.setItem('currentProfile', currentProfile);
                         // Load collapsed state for the new current profile
                         try {
                             collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories_' + currentProfile)) || {};
                         } catch (e) {
                            console.error("Error loading collapsed state for new current profile", currentProfile, e);
                            collapsedCategories = {};
                         }

                        profileSwitchedOrRefreshed = true;
                    }
                    if(Object.keys(profiles).length === 0) { // Should technically not happen with the check above, but as a fallback
                        profiles["Default"] = []; currentProfile = "Default";
                        localStorage.setItem("currentProfile", currentProfile);
                         // Load/initialize collapsed state for the default profile
                         try {
                             collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories_Default')) || {};
                         } catch (e) {
                             console.error("Error loading collapsed state for default profile", currentProfile, e);
                             collapsedCategories = {};
                         }
                        profileSwitchedOrRefreshed = true;
                    }
                    localStorage.setItem("profiles", JSON.stringify(profiles));
                    populateProfileModal(); loadProfileOptions();
                    if (profileSwitchedOrRefreshed) {
                        exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat);
                        renderExercises();
                    }
                }
            };
        });
        document.getElementById('new-profile-name-input').value = '';
    }

    document.getElementById('add-profile-btn').onclick = function() {
        const newProfileNameInput = document.getElementById('new-profile-name-input');
        let newName = newProfileNameInput.value.trim();
        if (!newName) { alert("Please enter a profile name."); return; }
        if (Object.keys(profiles).map(p=>p.toLowerCase()).includes(newName.toLowerCase())) {
            alert(`Profile "${newName}" already exists (case-insensitive).`); return;
        }
         // Stop any active timer before creating a new profile
         stopTimer();

        profiles[newName] = []; currentProfile = newName;
        localStorage.setItem("currentProfile", currentProfile);
        localStorage.setItem("profiles", JSON.stringify(profiles));
        exercises = [];

         // Initialize collapsed state for the new profile as collapsed (all true)
         collapsedCategories = {};
         allCategories().forEach(cat => collapsedCategories[cat] = true); // Collapse categories
         WEEKDAYS.forEach(day => collapsedCategories[day] = true); // Collapse weekdays
         localStorage.setItem('collapsedCategories_' + currentProfile, JSON.stringify(collapsedCategories));
         console.log(`New profile "${newName}" added, initialized collapsed state.`);


        loadProfileOptions(); populateProfileModal(); renderExercises();
        newProfileNameInput.value = '';
        alert(`Profile "${newName}" added and selected.`);
    };
    document.getElementById('profile-modal-overlay').onclick = closeProfileModal;

    document.addEventListener('DOMContentLoaded', () => {
        loadProfiles(); loadCategoryOrder(); // Ensure categories are loaded before initializing collapsed state
        loadProfileOptions(); // Ensure profile select is populated


        exercises = (profiles[currentProfile] || []).map(ensureScheduleFormat); // Ensure exercises are in correct format on load
        isWeekly = localStorage.getItem('isWeeklyView') === 'true'; // Load view mode preference

        // Load or initialize collapsed state for the initial profile
        const collapsedKey = 'collapsedCategories_' + currentProfile;
        const storedCollapsed = localStorage.getItem(collapsedKey);

        if (storedCollapsed === null || storedCollapsed === undefined) { // Check for undefined too
             // First time loading this profile - collapse everything
             collapsedCategories = {};
             // Need categories to collapse, so ensure categoryOrder is loaded first
             if (categoryOrder.length === 0) loadCategoryOrder(); // Defensive check
             allCategories().forEach(cat => collapsedCategories[cat] = true); // Collapse categories
             WEEKDAYS.forEach(day => collapsedCategories[day] = true); // Collapse weekdays
             localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save the newly collapsed state
              console.log(`Initial profile "${currentProfile}" loaded for the first time or key missing, collapsing sections.`);

        } else {
            // Profile has been loaded before, load saved collapsed state
            try {
                 collapsedCategories = JSON.parse(storedCollapsed);
                 console.log(`Initial profile "${currentProfile}" loaded, restored collapsed state.`);
            } catch (e) {
                console.error("Error parsing collapsed state on DOMContentLoaded for profile", currentProfile, e);
                collapsedCategories = {}; // Fallback to empty (uncollapsed) on parse error
                localStorage.setItem(collapsedKey, JSON.stringify(collapsedCategories)); // Save empty state
            }
        }

        renderExercises(); // Render using the loaded category order and collapsed state
        populateExerciseCategoryDropdown(); // Populate dropdown using the loaded order

         // Migration check for old collapsedCategories storage (non-profile specific) - run once on load if needed
         const oldCollapsedState = localStorage.getItem('collapsedCategories');
         if (oldCollapsedState !== null && oldCollapsedState !== undefined) {
             const newCollapsedKey = 'collapsedCategories_' + currentProfile;
             const newCollapsedKeyExists = localStorage.getItem(newCollapsedKey) !== null;

             // Only migrate if the old key exists and the NEW profile-specific key does NOT exist
             if (!newCollapsedKeyExists) {
                 console.log(`Migrating old non-profile collapsedCategories state for profile "${currentProfile}"...`);
                 try {
                      const stateToMigrate = JSON.parse(oldCollapsedState);
                      if (typeof stateToMigrate === 'object' && stateToMigrate !== null) {
                         localStorage.setItem(newCollapsedKey, JSON.stringify(stateToMigrate));
                         console.log("Migration successful. Old key 'collapsedCategories' is now redundant.");
                         // Optionally remove the old key after successful migration
                         // localStorage.removeItem('collapsedCategories'); // Consider removing this after a few versions
                      } else {
                         console.error("Old collapsedCategories data is not a valid object, skipping migration.");
                         // Initialize the new key as empty if migration failed
                         localStorage.setItem(newCollapsedKey, JSON.stringify({}));
                      }
                 } catch(e) {
                      console.error("Error parsing old collapsedCategories for migration:", e);
                      // Initialize the new key as empty if migration failed
                      localStorage.setItem(newCollapsedKey, JSON.stringify({}));
                 }
                 // After potential migration, reload collapsedCategories from the correct key
                 try {
                     collapsedCategories = JSON.parse(localStorage.getItem(newCollapsedKey)) || {};
                 } catch (e) {
                     console.error("Error reloading collapsed state after migration:", e);
                     collapsedCategories = {};
                 }
                  renderExercises(); // Re-render to reflect potentially migrated collapsed state
             }
         }
         // Initialize previousProgressPercentage on load
         updateProgress();
    });

  </script>
</body>
</html>
